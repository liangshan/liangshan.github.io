<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Liangshan]]></title>
  <link href="https://liangshan.blog/atom.xml" rel="self"/>
  <link href="https://liangshan.blog/"/>
  <updated>2021-01-29T15:28:40+08:00</updated>
  <id>https://liangshan.blog/</id>
  <author>
    <name><![CDATA[Liangshan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[我的工程师公理[翻译]]]></title>
    <link href="https://liangshan.blog/blog/2021/01/27/my-engineering-axioms/"/>
    <updated>2021-01-27T18:03:59+08:00</updated>
    <id>https://liangshan.blog/blog/2021/01/27/my-engineering-axioms</id>
    <content type="html"><![CDATA[<p>上次提到过，我不喜欢写一些时效性很强的内容（<del>强调我不是没时间写博客</del>）。一年多过去了，终于又看到一篇值得翻译的文章，网上能找到另外一篇现成的中文翻译，是一个简化的版本。我还是决定完整的翻译一下，不过每一条标题我认为都应该简短精炼，所以有些没有完全按照原文翻译。</p>

<p>这篇文章涵盖了编程的经验、对编程这份工作的理解、什么是职业态度等方面。其中的一些观点我深表赞同，有些观点超越了我认知的层级，将我带到更高的视角中。所以我个人非常推荐这篇文章。</p>

<!--more-->


<p><a href="https://martinrue.com/my-engineering-axioms/">原文 - My Engineering Axioms</a></p>

<hr />

<p>公理(Axiom) 是一个奇特的词，一层层挖掘词源最终找到了一个古希腊的词根 ἀξίωμα，称之为“被认为合适或值得的”。我喜欢这个概念，并且我认为这个列表中的每一项都是值得思考。</p>

<p>当然，它们仅仅是我<strong>个人</strong>的公理，基于我自己的经验而来。大家的经验或许和我不同。</p>

<p>无论如何，我很乐于分享这个列表，并进行一些简要的说明。其中一些见解可能会相当常见，但我也希望大家能产生不同的见解或发表有趣的不同看法。</p>

<h3>第一条 变化是永恒的</h3>

<p>这条应该不会有什么争议。几乎任何事情都是一直在变化的，甚至包括变化频率本身。我们需要知道的是应对变化的能力是至关重要的，除此以外应对变化的结果（时间成本、费用成本、质量、可靠性）也是很重要的竞争力。</p>

<h3>第二条 产品是资产，代码是负债</h3>

<p>你的产品解决了客户的问题，创造了价值，因此是你的资产。而代码是创造产品过程中要复出的代价。代码越多，就需要花更多精力去阅读、测试、维护和理解。尤其是考虑到第一条，这显得更为重要。要保守的接受新代码。最好的代码就是那些不用写的代码。</p>

<p><em>译者注：这一条需要反复品味，没吃过很多亏写不出这一句:)尤其作为团队管理者或者架构师，要时刻留意需求的实现方式。要选用最适合当前产品所处阶段的、综合成本最小的方式来完成。</em></p>

<h3>第三条 不要过早抽象</h3>

<p>除非你非常有信心，并且确定抽象可以解决已经实际存在的问题，否则不要做，等待更多信息。在此之前，重复代码可以避免依赖问题，这使得代码可以更轻松的修改或删除，而不互相影响。过早的抽象只会因为依赖关系和不再直接而增加复杂度，并且成为快速响应变化时的瓶颈。</p>

<h3>第四条 代码应该可以轻松删除</h3>

<p>写可删除的代码，很大程度上和解耦是一个意思。当然并不是说所有代码都需要简单的可删除，但最小化依赖、精确定义过的接口从而得到清晰的边界、合理的整体设计可以使得每个部分都变得更容易删除。我曾经听人使用“花费的代码(code spent)”这种表达，用来代替我们常说的“写过的代码(code written)”，我个人很喜欢这种说法。我也认可删除代码可以降低未来成本。</p>

<p><em>译者注：老实说本人没有非常理解 code spent 和 code written 的差异。</em></p>

<h3>第五条 现存代码的影响力</h3>

<p>存在即表明正确性及合理性。我们总是希望如此，但也不全对。我们需要有自信去修改旧代码，同时审视是否应该这么做。不要让旧代码的存在使得我们怀疑它们无法被移除。如第四条所说，如果系统设计的足够好，就会让我们更容易判断是否还需要现存的代码。</p>

<p><em>译者注：这一条说的有点啰嗦，其实就是辩证的看待是否要对旧代码动刀子。一般来说已经写好的代码都是有历史原因的，不要在不了解的情况下轻易去动，但也不是说永远都不要碰它们。</em></p>

<h3>第六条 偶发复杂性是最大的风险之一</h3>

<p>偶发复杂性特指本来可以避免的，由于糟糕的设计、错误的决定、没有选择适合的实现方式而导致的系统复杂性。如果不以最简洁为目标，这种复杂性会随着系统的增长从而最终导致方方面面的负面效应，甚至到很难理解整个系统的程度。2006 年的论文《<a href="http://curtclifton.net/papers/MoseleyMarks06a.pdf">Out of the Tar Pit</a>》是关于这个话题值得一读的内容。</p>

<p><em>译者注：偶发复杂性（Accidental complexity）是相对于必要复杂性（Essential Complexity）的概念。简单来说就是世界上有两种复杂，一种是这个事本来就很复杂，一种是人为的搞复杂了。“Accidental complexity”特指后者，相关概念最早出现在《人月神话》中著名的“No Silver Bullet”章节。</em></p>

<h3>第七条 卓越的技术有可能被糟糕的个人行为所掩盖</h3>

<p>除非你是完全一个人工作，否则重要的不只是解决技术问题，写出良好代码的能力。如果你让身边的人都感觉不舒服或者更低效，这反而是更严重的问题。就像你要学习写好的代码，你也得学着做一个“好人”。同理心是做好这一点很重要的因素，要认识到每个人都不同。关心，理解，帮助他人，寻求帮助，变得友善。做一个大家都喜欢跟你一起工作的工程师。</p>

<p><em>译者注：工程师不只要变的专业，还要具备一定的职业素养。这确实是很多人都会忽略的问题。</em></p>

<h3>第八条 对写代码的人友善</h3>

<p>代码本质上只是反应了我们所知所想的某个瞬间。代码并不能代表你，你可能写了这段代码，即使只过了三分钟你也已经成长了，但代码没有。针对一段代码好坏的讨论，永远都不应该牵扯到写它的人。要学会保持职业的态度。谈论代码，或者谈论问题，但不要牵扯到谁写的。讨论时更多的使用“我”而不是“你”。有时候我甚至会假设是我自己写了这段别人的代码，这样可以帮助避免显得听起来是在针对人。</p>

<h3>第九条 保持尊重和耐心</h3>

<p>我们每个人都是从某一处开始起步，假设你身边是一群有耐心的、希望你能成功的人，肯定比一群让你自己感觉不属于这里的人舒服多了。如果你感觉这条让你很挣扎，试着想象一个新手工程师肯定在某一方面比你强，比如外语或者做饭或者某项运动。想象跟他互换角色，你会喜欢他们如何对你？再次重申：做一个大家都喜欢跟你一起工作的工程师。</p>

<p><em>译者注：这里我想补充一点，不只是对新手工程师，还包括对其他部门不懂技术的同事，不要展现出高高在上的技术大神的感觉，言语中透露出“你什么都不懂还来跟我讨论”的鄙夷之情。要用对方听得懂的方式交流，耐心的交流。</em></p>

<h3>第十条 真正的权威来自知识而非职位</h3>

<p>专业知识和对于问题、领域、客户的理解，远比名片上的前三个词重要——即使是有水印的那种。深入理解事情的运作方式，建立一套扎实的基础知识，权威会随之而来。</p>

<p><em>译者注：“即使是有水印的那种” 出自一部美国电影：American Psycho，影片中几个商务人士在炫耀各自的名片。</em></p>

<blockquote><p>“Look at that subtle coloring. The tasteful thickness.&#8221;</p>

<p>&ldquo;Oh my God. It even has a watermark.”</p></blockquote>

<h3>第十一条 教是一种变相的学</h3>

<p>如果你觉得你懂些什么，试着教一下。通常试着给别人解释你知道的事情会迫使你了解的更清楚。同样的，把事情写下来也有类似的效果。我自己有无数次的以为自己很懂，但当我开始给别人讲解时却发现并没有。</p>

<h3>第十二条 让周围的人一起变强</h3>

<p>团队不会因为一个厉害的人而变得强大。强大的团队一定是因为每个人都在挑战自己不断进步。当你学到什么好东西，分享它从而让你身边的一人一起变强。如果每个人都这么做，所有人都会从中受益。这会有趣的多。另外一个理由是第十一条。</p>

<h3>第十三条 等的越久知道的越多</h3>

<p>我仍在学习这一点并努力的避免内心中想要快速做决定的直觉。事实上，处理不紧急的事情时拖延的越久，做决定时掌握的信息越多。当然不能总是拖延做决定，但至少你可以思考当下先不知道答案是否可行。</p>

<h3>第十四条 好的类型系统值得加大比重</h3>

<p>我的职业生涯在静态和动态语言之前来回切换过数次，我目前认为好的类型系统值得为它花上一些功夫。那是因为好的类型系统不会有太多开销。假如类型系统设计的好的话，用起来的感觉会非常接近动态语言（通过推理和流分析来实现），同时会避免整整一大类问题，因为编译器可以更快更好的处理这些问题。Rust 中的 <code>ownership</code> 就是一个很好的例子，证明这个思路发展的很好，甚至比过去几年设想的还要更进一步。</p>

<h3>第十五条 正确的团队成员胜过一切</h3>

<p>团队里有一群想要一起创造出伟大产品的人，会使得很多其他问题变得简单。这里的“正确”一次是很主观的，且依赖于所处的环境。至少同理心，尊重和友谊一直是我参与过的伟大团队的常识。</p>

<h3>第十六条 适当的守旧</h3>

<p>过时的技术意味着更老但理解的更深。在如何高效的使用，更好的了解故障模式，更容易找到人和资源应用这些技术方面，有着前人辛苦积累的宝贵经验。我非常喜欢 Dan McKinley 提出的创新代币的说法。你只有三个创新代币，用来构建新东西，那些理想情况下会使得核心更牢固的新东西，超过三个的话稳定性和成熟度的风险就会增加。</p>

<p><em>译者注：这是另外一个需要辩证看待的问题，就如同前面提到的要不要重构现有代码一样。适度的引入新技术，旧技术栈有它自己的优势。这个问题比较见仁见智了，我自己是保守的改革派。</em></p>

<h3>第十七条 谨慎的扩张团队</h3>

<p>这句话改编自一句名言，你当前团队的情况可能会不太一样。从我的职业生涯来看，更小的团队往往更高效。当然了，我们需要找到一个平衡点，取决于每个团队所面临问题的重要性和复杂度。通常来说，更小的团队意味着更少的沟通开销，更少的误解，更容易让每个人都发声。并且在一个小团队中，每个人都感觉更个性化，也更有责任感，我喜欢这样。</p>

<h3>第十八条 适度休息</h3>

<p>我很高兴看到“996让你成功”这种态度的淡化，人们花更多精力用于追求精神健康和快乐。没有充分休息的时候将无法感受到快乐，而不快乐何来最佳状态？也就是说，为了达到最佳状态，必须得到一定的休息。我认为休息也是工作的关键部分，就像体育锻炼一样。</p>

<p><em>译者注：鎴戝幓浣犲ぇ鐖风殑</em></p>

<h3>第十九条 至少有两个选择再做决定</h3>

<p>当你脑子里听到叮的一声，这时你意识到你找到了解决问题的方法。或者这只是一个很琐碎的小问题，没什么其他要做的了。但如果这个问题并非小问题，就值得思考一下是否有更佳的答案。</p>

<p>为了避免那种找到方案的兴奋感驱使你直接使用第一个冒出来的想法，试着找到至少一个其他答案。找其他解决方法的过程往往会迫使你想的更多，而一旦有了两个方案你就要考虑如何做取舍。这整个过程会帮助你更清晰的认识问题。</p>

<h3>第二十条 发表意见时不要让人以为你只是固执己见</h3>

<p>表达自己的想法是很重要的，团队应该永远都有这么做的空间。但有条界限分割着正常表达和给人固执己见的感觉。在一个团队中，每个人都感觉自己能挑战一个决定或者改变某些事，这是非常健康的。</p>

<p>我曾经收到过一个很不错的建议，就是在你发表看法的时候带上百分比。“我有九成把握觉得使用 Visual Basic 不是个好主意”。即使是 95%，至少给其他人留了一个质疑和沟通的窗口，也给你自己一个接收新信息来降低自己确定性的机会。</p>

<h3>第二十一条 学会说我不知道</h3>

<p>老实说，我们没人知道我们真正在做什么。至少我不知道。我们所处的行业变化太快，有太多刚刚过时的东西，同时又有太多新冒出来的东西。我们每天都在学习，也没有一个所谓差不多了的标准答案。我们的价值并不是知道所有的事情，我们的价值是不断的学习，去发现并解决问题，然后探索新的问题。</p>

<p>假如有人跟我说“我不知道”我会很兴奋，因为这是一个一起探索问题一起学习的好机会。不要因为好像只有你一个人不懂就隐藏起来。其实通常是别人也不知道，但你的诚实会带领大家都公开的加入进来一起寻找答案。</p>

<h3>第二十二条 动手折腾，然后扔掉</h3>

<p>快速的试错几次比想要一开始就弄对要快多了。有时候探索问题最好的方式就是在它周围来回动手尝试，尽可能的学习。</p>

<p>有时候你还没有真正理解某个问题的领域，但直接动手试一下，也许会发现很多高层次的设计思想和文档中忽略的细节。尽情去试错，等到得出答案就可以把这些临时的内容一起丢掉，这种方式你会学的非常快。</p>

<p><em>译者注：这种方式不仅适用于开发团队，更广泛的说适用于互联网开发的几乎所有场景，比如可以快速实现一个原型让需求方体验从而尽快发现改进的方向，也可以快速上线一个版本，让用户告诉你改进是否有效。</em></p>

<h3>第二十三条 重视管理状态</h3>

<p>每个应用程序都有状态，但如何管理状态的方式会导致结果大相径庭。不太好的做法会使得状态管理成为整个系统复杂度的重要来源，这通常由于在问题没有变的更糟糕的之前没提前思考这个问题。</p>

<p>有很多策略可以提供帮助，比如在给定的环境中使用特定的方法来处理状态，或是使用函数式编程或其他方法，以围绕状态应该如何变化创造出更严格的约束。无论怎么做，都应该花时间仔细考虑这一点。</p>

<p><em>译者注：这一点上大前端（即非后端的统称）工程师应该更有体会。</em></p>

<h3>第二十四条 一切都是权衡</h3>

<p>大多数时候当你做了一个决定，就意味着有意无意间在其他决定之间权衡。有时候这种权衡很明显，但也有时离我们眼前所见隔了几层。要保持思考每个决定的权衡点，即使有些并不明显。</p>

<p>这里有个很好的例子就是 Go 语言。Go 的类型系统还很简陋（当前来说），它还只是一门很小的语言。这里的权衡是什么呢？由于它的还很小，以及对于各种花式写法的限制，导致我的代码和其他人的代码看起来很相似，这会提高我的生产力。不像我以前写其他语言时的体验，看了别人写的东西就会心想：“我必须尽快重构”。永远都要做出权衡，找到这些要权衡的点，你就会做出更好的决定。</p>

<h3>第二十五条 能方便修改的设计就是好设计</h3>

<p>根据第一条经验，意味着我们必须很好的处理变化才能成功。这些变化不仅仅是指那些推着我们往前走的外部变化，还包括了内部的变化，比如新功能和规模的变化带来的挑战等等。</p>

<p>好的系统设计应该能够尽可能的包容我们要经常变化的需求，而不用每次都从头开始。换言之，我们需要更改或删除的部分越少，越快能够面对变化，越是好的设计。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[工程师的未来]]></title>
    <link href="https://liangshan.blog/blog/2019/11/16/future-engineering/"/>
    <updated>2019-11-16T14:42:15+08:00</updated>
    <id>https://liangshan.blog/blog/2019/11/16/future-engineering</id>
    <content type="html"><![CDATA[<p>今天本来在睡午觉，突然感觉有种写东西的冲动，爬起来把最近一直在思考的事情记录一下。</p>

<p>如今开发软件的方式正在发生深刻的变革，回想起刚毕业的时候做软件开发工程师，和现在已经截然不同了。</p>

<!--more-->


<p>最早运维工程师往往是公司里一个独立的团队，公司租用公共机房的机器，大一些的公司也会选择自建机房。上架新机器（俗称扩容）是个流程繁复的事情，从公司决定采购到物理机器到位这中间有很长的时间间隔。</p>

<p>在实际的业务开发过程中，开发工程师在项目结束之后需要正式的「移交」给运维工程师来处理后续的事情。然而全栈工程师的概念慢慢流行起来，推崇「You build it, you run it」。高级的工程师可以拿到线上本来只有运维才有的权限，自己写的代码自己考虑部署、监控、告警。</p>

<p>DevOps 也开始深入人心，运维团队中出现了很多自己开发的工具，上线系统、配置管理、监控告警平台等等。</p>

<p>但无论怎么变化，所有软件和硬件都还在自己的机房里，直到云服务的到来。</p>

<p>也就是我们目前所处的环境，软件和硬件都走上了云端，即使那些还在自己经营机房的大公司，本质上也是一个内部的云服务商。云服务的核心是虚拟化，任何人都可以很轻松的在几分钟之内申请到新的虚拟机器（将来可能是容器）。运维工程师进化为了可靠性工程师，以设计软件运行环境和管理软件配置为主。</p>

<p>说完现在，就要说未来了。</p>

<p>很久之前读过<a href="https://book.douban.com/subject/24536403/">《代码的未来》</a>，今天想讨论一下几类工程师的未来的工作方式。</p>

<h3>DevOps</h3>

<p>无论是自建机房还是云服务，运维工程师一直无法避免要知道「什么东西部署在什么机器」。然而 Docker 和 K8S 的出现将彻底的改变这个情况，无论多庞大的集群，交给软件自动来编排。软件的标准化、部署、迁移的方式得到了质的变化。</p>

<p>运维工作需要更加深入到业务中，了解项目打包的过程，管理公司内部的镜像，提供标准化的持续集成的工具，提供各个项目的 docker 开发环境。</p>

<h3>数据工程师</h3>

<p>说到这个感触就更深了，因为我们数据仓库的基础设施刚刚完成从自建 CDH 到云上服务的迁移。</p>

<p>一直以来，我们已经习惯了离线数据和大量计算的需求使用其他工具来完成，比如各种 ETL 工具和 Hive。然而现在的趋势是将存储和查询引擎解耦开来，无论是什么存储，都使用同一套协议（比如 MySQL）来查询。</p>

<p>也就是说无论是分析师还是 ETL 工程师，只要会 SQL 语句就可以了，更重要的是代码层面完全统一。</p>

<h3>开发工程师</h3>

<p>开发工程师以后只关注生产业务逻辑即可，随着高级语言的发展，不需要懂底层的知识也可以开发出高效稳定的软件。</p>

<p>以 Go 语言为例，代码层面交互的只有 goroutine，背后是协程还是线程还是进程，语言的底层来帮你解决。越来越多的第三方库帮你做掉了大部分的工作，工程师只需要看着文档会调用即可。</p>

<p>Serverless 可能会成为主流，即写完业务逻辑不需要申请服务器，直接在云端运行。</p>

<h2>总结</h2>

<p>无论是哪个领域，计算机软件的生产都走向了「使用越来越简单，背后越来越复杂」的方向。</p>

<p>我认为公司需要的<strong>技术专家和架构师将大幅度减少</strong>，与此同时<strong>云服务使用专家</strong>将成为新的需求。</p>

<p>普通工程师也许真的可以变成简单培训即可上岗的职业，普通工程师的可替代性会进一步提高，核心技术掌握在极少数大型公司，尤其是云服务公司之中。</p>

<p>开源软件将走向「社区孵化，云服务商私有化」的道路，最终开源软件将被头部云服务商垄断，然后变成 SaaS 最终成为云服务商的现金流。</p>

<p>从企业家的角度来看，生产软件的成本可能会降低（尤其是人力成本）。但从工程师的角度来看，其实有点悲观的，要么努力成为顶部的技术专家，要么就会变得随时可以被代替了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精益敏捷开发]]></title>
    <link href="https://liangshan.blog/blog/2019/09/12/lean-scrum/"/>
    <updated>2019-09-12T17:15:35+08:00</updated>
    <id>https://liangshan.blog/blog/2019/09/12/lean-scrum</id>
    <content type="html"><![CDATA[<p>我们团队一直在实践 Scrum，同时我对精益软件开发里面的一些思想又非常认可。
确切的说，精益软件开发是从敏捷开发思想中进一步发展而来，所以今天混在一起谈一下精益开发中的「消除浪费」和敏捷开发中的「回顾会议」。</p>

<!--more-->


<p>Scrum 就不用多做介绍了，敏捷开发中非常流行的方法论之一。但是精益软件开发讨论的相对少一点，以下内容摘抄自维基百科：</p>

<blockquote><p>精益软件开发是精益制造原则和实践在软件开发领域的变体。</p>

<p>和精益制造原则的概念相近，精益开发也可以总结为如下七条原则：</p>

<ul>
<li>消除浪费</li>
<li>增强学习</li>
<li>尽量延迟决定</li>
<li>尽快发布</li>
<li>下放权力</li>
<li>嵌入质量</li>
<li>全局优化</li>
</ul>
</blockquote>

<h3>消除浪费</h3>

<p>在我看来，精益开发除了认同敏捷开发的思想之外，最突出的就是强调了消除浪费。</p>

<blockquote><p>为了消除浪费，首先必须能够识别、认识到浪费。如果某项活动可以被跳过或者取消也能达成最终的结果，那它就是浪费。在开发过程中作成但最终被废弃的代码是浪费；客户不经常使用的额外的处理和特性是浪费；令人员在多个任务间切换是浪费；等待其他任务是浪费；缺陷和低品质是浪费；不产生实际价值的、过度的管理也是浪费。</p></blockquote>

<p>实际工作中这种情况其实很常见，并且往往是因为想要把事情做的更好，尤其是处于上升期的工程师。我自己也有这种阶段，恨不得把毕生所学都用在进行的项目上，却忘了团队还等着你交付产出。</p>

<p>这里尤其要注意的是，精益并没有将尽快发布和质量对立起来，相反的，精益强调在开发过程中就应该嵌入质量管理，认为缺陷和低品质是一种浪费。可能会有人有疑惑，快和好不是矛盾的吗？我对这一条有两层理解：第一，强调的质量是指在去掉那些浪费的功能和设计之后，提交的代码仍然应该是高质量；第二，我们允许临时用低品质的方法解决问题，但技术债要很快偿还。尤其是第二点，做到非常不容易，在我们团队尝试依靠敏捷开发来解决，每个 Sprint 都引入一个重构或优化的单子，尽早把低质量扼杀在摇篮里。一旦一个地方产生垃圾，那么大家都会往那里丢垃圾，这一点相信很多人都深有体会。</p>

<h3>回顾会议</h3>

<p>接下来重点谈一下让回顾会议变得更加高效的一套方法，我们称之为 Health Check Model。</p>

<p>回顾会议有两个非常难解决的问题，一个是大多数人都等着别人发言，很少贡献有价值的内容；另一个是每一期的话题很散，有时候重点讨论了流程却忽视了规范，有时候在一个系统的改进上讨论了很久却忘了我们这一个 Sprint 有很多单子没有完成，有很多值得改进的地方。我一直在找有什么办法可以把回顾会开的更有价值。直到有一天看到了别人在实践一套叫 Health Check Model 的方法，这个方法最早是由 <a href="https://spotifylabscom.files.wordpress.com/2014/09/squad-health-check-model2.pdf">Spotify 团队提出的</a>，在我们团队实践之后感觉效果非常好，所以重点介绍一下我们目前的做法。</p>

<p>这套方法的流程就是提前准备好一系列要表决的内容，类似计划会打分的环节，针对每一项内容每个团队成员都要给出自己的选择。如果做的很好就给绿灯，反之就给红灯，一般就给黄灯，最后统计每种选择的数量来决定最后的结果，然后记录下来就是这样一个表格：</p>

<p><img src="https://liangshan.blog/images/custom/HCM.png" width="520px" /></p>

<p>针对我们团队的情况，我做了几个改变。首先是把黄灯拿掉了，不给选一般的机会:D，然后通过红灯的比例来决定最终的结果，达到四分之一（包含）为黄，达到二分之一为红。另外把 Spotify 原始的几项内容做了改变，比如 Easy to Release，编写上线脚本集成到上线系统，这个是我们的基本要求，所以每周大家都给绿灯，就删掉了。但我额外增加了 Feedback，意思是有没有其他团队的人来找我们反馈问题，包括但不限于线上 Bug、数据质量、风控风险等等。</p>

<p>具体的每项定义如下：</p>

<ul>
<li>Fun，非常简单直接，自己工作的是否开心；</li>
<li>Health of Codebase，代码质量，自己的或自己 Review 的；</li>
<li>Learning，有没有保持学习，一般情况下敏捷开发是不关注这一项的，但我非常认可这一项。其实并不是要求大家每周都要学东西，毕竟工作不是上大学。但这一条提醒大家别忘了自己是工程师，需要不断学习保持竞争力，我们没有惩罚，但是会让小伙伴分享学到的内容。先小范围分享，如果大家觉得内容不错，会组织整个技术部再分享一次；</li>
<li>Mission，是否清楚自己近期的主要任务。这很重要，没有目标每天就只有被任务推着走。我会给每个人安排和工作内容相关的，较为复杂的一个 Mission，需要自己花一个季度甚至更久来持续改进的项目；</li>
<li>Pawns or Players，棋子或玩家。玩家就是说能站在需求方的角度思考问题，能主动想把事情做的更好；</li>
<li>Speed，速度。不只是完成项目的速度，还包括给别人反馈的速度；</li>
<li>Suitable Process，做事是否按照合适的流程。其实很多问题最后都是流程问题，比如上线的流程、开发的流程；</li>
<li>Teamwork，团队合作。技术团队的合作主要是体现在 Review、技术文档等方面，所以这一项我们使用的标准是知不知道其他成员在做什么，有没有积极 Review 别人的代码；</li>
<li>Feedback，反馈。前面已经解释过了，有没有人来反馈问题。</li>
</ul>


<p>如果仔细思考一下，你会发现基本上技术团队日常工作的方方面面都考虑到了，每一项打完分该讨论的也都差不多了，如果还有没说到的问题，可以再经过一轮自由发言的补充。在这个过程中，如果有人给了和大多数人不同的颜色就必须要发言，通过这种形式也让每个人都能参与进来。</p>

<p>以上就是我们在实践中遇到的一些问题和对应的解决方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My 2018]]></title>
    <link href="https://liangshan.blog/blog/2018/12/29/my-2018/"/>
    <updated>2018-12-29T16:11:07+08:00</updated>
    <id>https://liangshan.blog/blog/2018/12/29/my-2018</id>
    <content type="html"><![CDATA[<p>2008 年毕业一晃已经十年过去了，今年破天荒写一次年终总结吧。起因是昨天我们团队内部做了一些分享，其实是为了记录一下团队做过的事情。我本来以为我对团队了如指掌，但听完大家各自的分享，竟然还是有些莫名的感动，原来我们做了这么多事情。因此也算有感而发，这篇年终总结其实就是自己的管理心得总结。</p>

<h3>0 - Optimizing For Happiness</h3>

<p>这句话是 GitHub 早期员工在 2010 年左右介绍 GitHub 的时候，在一个演讲中提到的。这是我看过的对我影响最大的 PPT，这里面的理念到现在我都深信不疑。文章的基本逻辑是这样的：</p>

<ol>
<li>Optimizing For Happiness = Investing In Humans</li>
<li>Investing In Humans = A Happy Team</li>
<li>A Happy Team = A Great Product</li>
<li>A Greate Product = Happy Users</li>
<li>Happy Users = Paying Customers</li>
<li>Paying Customers = More Money</li>
</ol>


<p>综上可得 Optimizing For Happiness = More Money (当然是老板 ^_^)。</p>

<p>我也是照着做的，让他们开心工作，不想做的事情不强迫。但也许也有特例，比如公司组织的社交活动大家不想去就不去，我来搞定。但事实证明，这样做未必是对的，至少要分情况讨论。团队的人是高兴了，但可能给别人一种我们很高冷的感觉。我作为管理者需要考虑这样的影响和印象到底是好还是不好。</p>

<h3>1 - Documentation VS Presentation</h3>

<p>我们团队一直非常重视知识的积累和持续改进，按照我之前的想法这样就够了。但其实不够，因为缺了一步——展示给别人。和写文档最大的不同是，PPT 的关注点是思考过程，而不是像文档很详细的内容，思考过程恰恰是最能了解设计者思路，展示演讲者能力的。对演讲者自己来说，即是一次彻底的总结，也是向不了解某件事情的人展示自己价值的方式。让优秀的工程师发光，让他的成果被别人认可，而不只是把事情做好就够了，这是我近期想法的一个很大转变。</p>

<h3>2 - 今天上线 VS 从长计议</h3>

<p>做为管理者，经常需要平衡一个需求是「今天上线」还是「从长计议」，从一名工程师角度出发，我其实一直倾向于后者，把事情想清楚，好好设计一下再做，而不是在系统里到处临时打补丁。然而站在管理者的角度重新来看这个问题，未必是互斥的。很多事情其实可以「今天上线」，然后记个技术债慢慢「从长计议」。从最终结果来看，这样的策略各方的反馈是最好的。</p>

<h3>3 - 定期回顾是个好习惯</h3>

<p>我从 Scrum 里面保留了计划会、回顾会这样的形式。其中回顾会是每两周一次，每次开始之前都会点一杯奶茶、一份鸡蛋仔，然后互相「吐槽」。</p>

<p>从 2018 年 3 月份开始，我们已经沉淀了 30 多条切实可行的经验，团队成员提出了数十个真正改进了我们系统的想法。这些都是我们独有的、自发的、原创的宝贵经验，回顾会变成了大家最期待的环节（也可能只是期待吃的）。2019 年我们的回顾会要继续开下去。</p>

<h3>4 - 总结</h3>

<p>2018 年最大的感受就是，如果一个团队做的足够好，自己就会像一个太阳一样，不仅内部火热，还会辐射到其他团队。希望 2019 年，在这个所谓的寒冬，我们能继续开心工作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式系统架构概述（译）]]></title>
    <link href="https://liangshan.blog/blog/2018/05/04/distributed-architecture-concepts/"/>
    <updated>2018-05-04T11:58:05+08:00</updated>
    <id>https://liangshan.blog/blog/2018/05/04/distributed-architecture-concepts</id>
    <content type="html"><![CDATA[<p>我其实很少翻译东西，首先是因为英文和中文水平都有限，很难做到信达雅，其次一般的文章自己看过就结束了，很少有要翻译的冲动。这次要翻译的是一篇概括性很强的文章，讲的是分布式系统中需要了解的基础概念，值得保存下来经常回顾。</p>

<p>有趣的是，这篇文章在 <a href="https://news.ycombinator.com/item?id=16852295">hacker news</a> 和 <a href="https://www.reddit.com/r/programming/comments/8cxz7q/distributed_architecture_concepts_i_learned_while/">reddit</a> 上得到了基本相反的评价。我个人还是很认可这种概括性的文章的。就好像大学的课程大纲，有很强的指导作用。</p>

<p>以下是正文的译文，原文请戳<a href="http://blog.pragmaticengineer.com/distributed-architecture-concepts-i-have-learned-while-building-payments-systems/">这里</a>。</p>

<hr />

<p>两年前我做为移动开发工程师加入了 Uber，之前有一些后端开发的经验。我参与实现了 app 的支付模块——这个模块目前正在重写。之后，我开始进入工程管理领域，领导一个团队。这个团队负责很多和支付相关的后端系统，这意味着我更多的接触了后端开发的东西。</p>

<p>在 Uber 工作之前，我几乎没有分布式系统经验。我的教育背景是传统的计算机科学学位，之后做了十年全栈开发。虽然我之前略知一二，但我对分布式概念（如一致性，可用性或幂等性）没有太多的理解或欣赏。</p>

<p>在这篇文章中，我总结了一些构建大规模、高可用的分布式系统时需要了解的基本概念。这个系统就是 Uber 的支付系统，一个负载高达每秒数千次请求的系统，即使部分系统出现故障，关键支付功能也需要正常工作。 这是一个完整的清单吗？ 也许不是。 但如果我早点知道这些的话，会让我的生活变得更轻松。 因此，让我们深入了解 SLA、一致性、数据持久性、消息持久性、幂等性以及我在工作中需要学习的其他一些内容。</p>

<!--more-->


<h2>SLA</h2>

<p>对于那些每天处理数百万次事务的大型系统来说，出错几乎是无法避免的。我发现在深入计划一个系统之前，最重要的事情是先定义这个系统如何算「健康」。尽量用一些可衡量的指标来表示「健康」。通用方法是用 <a href="https://en.wikipedia.org/wiki/Service-level_agreement">SLA</a> 来衡量，即 service level agreements。我见过的最通用的 SLA 是：</p>

<ul>
<li><strong>可用性（Availability）</strong>：服务正常运行时间的百分比。显而易见的是应该努力让系统的可用性达到 100%，但做到这个目标不仅很难而且很贵。甚至像 VISA、Gmail、互联网供应商这样的大型且重要的系统都无法做到 100% 的可用性。历年来，他们总是会有那么几秒钟、几分钟、或者几小时不可用。对于大多数系统来说，4 个 9 的可用性（即 99.99%，换言之<a href="https://uptime.is/">每年不超过 50 分钟</a>不可用时间）即可被称为高可用。仅仅是达到这一水平通常已经意味着大量的工作要做了。</li>
<li><strong>准确性（Accuracy）</strong>：系统允许一些数据的丢失或不准确吗？如果允许，可以接受多大比例呢？对于我负责的支付系统来说，准确性的要求是 100%，意味着任何数据都不允许丢失。</li>
<li><strong>容量（Capacity）</strong>：系统预期可以承受多大的负载？这个指标通常使用 QPS(requests per second) 来表达。</li>
<li><strong>延迟（Latency）</strong>：系统应该在多久之后返回结果？95% 以及 <a href="https://www.quora.com/What-is-p99-latency">99%</a> 用户请求的响应时间是多少？系统通常会有一些噪音数据，所以取 95% 和 99% 请求的延迟时间是现实世界中的可行做法。</li>
</ul>


<p><strong>为什么 SLA 对于构建一个大型支付系统如此重要呢？</strong> 我们在构建将要替换当前系统的新系统。为了确保我们所做是正确的，即我们认为新系统是「更好」的，所以我们使用 SLA 来定义指标。其中可用性是我们优先级最高的要求。一旦确定了标准，我们就可以在架构过程中权衡选择来达到它。</p>

<h2>水平扩展（Horizontal scaling） Vs 垂直扩展（Vertical scaling）</h2>

<p>假如一个由新系统支撑的业务持续在增长，那么系统负载也在增加。到了某个节点，现有的设施已经无法支撑更多负载和容量。两种通常会考虑的扩展策略就是水平扩展和垂直扩展。</p>

<p>水平扩展就是通过加机器（或节点）来提升容量。水平扩展是目前分布式系统最流行的扩展方式，尤其是现如今对于集群来说，增加一台机器（或虚拟机）仅仅只是点一个按钮那么简单。</p>

<p>垂直扩展基本上就是「买一台更大更好的机器」，也就是更多核、更多进程、更多内存。对于分布式系统来说，垂直扩展通常没那么常见，因为垂直扩展往往要花费更多钱。但也有些大型网站，比如 Stack Overflow 就有过<a href="https://www.slideshare.net/InfoQ/scaling-stack-overflow-keeping-it-vertical-by-obsessing-over-performance">成功垂直扩展</a>来满足需求的案例。</p>

<p><strong>为什么扩展的策略对于构建一个大型支付系统如此重要呢？</strong> 我们早期就确定了支付系统应该是水平扩展的。虽然垂直扩展在某些场景下可行，但就目前市面上昂贵的单台大型主机负载能力而言，我们对它是否能承受目前支付系统的流量持悲观态度，更不用说将来。另外，我们团队有些工程师有大型支付系统工作的经验，当初他们想要使用能买到的最贵的主机来垂直扩展，然而失败了。（译者注：后面这些话好像并没有回答前面的问题）</p>

<h2>一致性（Consistency）</h2>

<p>可用性对于任何系统都是重要的。分布式系统往往构建于一批可用性相对较差的主机上。假设我们的目标是构建 99.999% 的可用性（即每年 5 分钟不可用），而我们使用的机器，平均只有 99.9% 的可用性（每年 8 小时不可用）。那么达到目标可用性的一种直接的方式就是使用一组这样的主机来组成集群。即便是某些节点不可用，其他的会保持可用来达到更高的可用性。</p>

<p>一致性是高可用系统的关键指标。如果系统的所有节点在同一时间返回相同的数据，则认为这个系统是一致的。回到刚才的话题，由于我们使用了一组机器来组成高可用集群，确保系统保持一致就至关重要了。为了确保每个节点都返回相同的信息，它们之间需要消息通信。但是，消息传递可能会失败、会丢失，有些节点甚至不可用。</p>

<p>一致性是一个我花了最多时间去理解和欣赏的概念。有很多一致性的模型，分布式系统中最流行的<a href="https://en.wikipedia.org/wiki/Consistency_model">几种模型</a>是<a href="https://en.wikipedia.org/wiki/Consistency_model">强一致性（strong consistency）</a>，<a href="https://www.cl.cam.ac.uk/teaching/0910/ConcDistS/11a-cons-tx.pdf">弱一致性（weak consistency）</a>和<a href="http://sergeiturukin.com/2017/06/29/eventual-consistency.html">最终一致性（eventual consistency）</a>。Hackernoon 的这篇<a href="https://hackernoon.com/eventual-vs-strong-consistency-in-distributed-databases-282fdad37cf7">强一致 vs 最终一致</a>给出了很好的可行的权衡建议。通常来讲，一致性越弱，系统越快，但拿不到最新数据的可能性也会越高。</p>

<p><strong>为什么一致性对于构建一个大型支付系统如此重要呢？</strong> 系统中的数据要保持一致。但要多一致呢？对于系统的某些组件来说，只有强一致能满足要求。比如，确认一个支付是否已经初始化的数据需要确保强一致性。其他一些组件，也就是那些不太重要的组件，最终一致性是可以考虑的选择。一个很好的例子是近期交易列表，就可以使用最终一致性策略来实现（这意味着最新的交易未必立刻出现在列表里，但换来了更低的延迟和更小的资源消耗）。</p>

<h2>数据耐久性（Data Durability）</h2>

<p><a href="https://en.wikipedia.org/wiki/Durability_(database_systems)">耐久性</a>意味着数据一旦被成功存储就可以一直继续使用。即使系统中的节点下线，崩溃或数据损坏也是如此。</p>

<p>不同的分布式数据库拥有不同级别的耐久性。有些系统支持机器/节点级别的耐久性，有些做到了集群级别而有些系统的耐久性并没有开箱即用。某种形式的数据复制是较为通用的提高耐久性的做法，因为把同一份数据存储在不同的节点上，即使有节点下线，数据仍然可以被访问。<a href="https://drivescale.com/2017/03/whatever-happened-durability/">这篇文章</a>很好的解释了为什么分布式系统做到耐久性是很大的挑战。</p>

<p><img width="800px" src="https://liangshan.blog/images/custom/data-durability.png" /></p>

<p><strong>为什么数据耐久性对于构建一个支付系统如此重要呢？</strong> 这个系统的大部分组件而言，如此重要的数据是不允许丢失的。分布式的数据存储需要支持集群级别的数据耐久性，即使实例会崩溃，完成了的交易仍然还在。现如今大部分分布式数据存储服务，诸如 Cassandra、MongoDB、HDFS 或是 Dynamodb 全都支持不同级别的耐久性，并且通过配置都可以支持集群级别的耐久性。</p>

<h2>消息的持久化（Persistence）和耐久性（Durability）</h2>

<p>分布式系统中的节点进行计算、存储和相互发送消息。发送消息的一个关键性指标是消息送达的可靠性。对于重要的系统而言，常常不允许任何消息的丢失。</p>

<p>对于分布式系统而言，消息通讯通常由分布式消息服务完成，比如 RabbitMQ、Kafka。这些消息服务能支持（或配置后支持）不同级别的消息送达可靠性。</p>

<p>消息持久化的意思是当消息服务的节点发生了错误，已经发送的消息仍然会在错误解决之后被处理。消息耐久性则通常用在消息队列这一层。如果一个消息队列声明了耐久性，那么即使队列在消息发送之后掉线，仍然会在重新上线之后收到这条消息。<a href="https://developers.redhat.com/blog/2016/08/10/persistence-vs-durability-in-messaging/">这里</a>有一篇很好的文章是关于这个话题。</p>

<p><img width="800px" src="https://liangshan.blog/images/custom/msg-durability.png" /></p>

<p><strong>为什么消息的持久化和耐久性对于构建一个支付系统如此重要呢？</strong> 我们有太多重要的消息经不起丢失，比如乘客刚刚初始化了行程的消息。也就是说我们的消息系统是不允许丢消息的，每条消息都会被投递一次。但是，每条消息精确投递一次和至少投递一次是截然不同的复杂度。我们最终决定了实现一个耐久的消息系统，每条消息至少被投递一次，在底层选择了一个消息总线（最终我们选择了 Kafka）。</p>

<h2>幂等性（Idempotency）</h2>

<p>分布式系统偶尔会出错，比如连接会断开或是请求会超时。客户端经常需要重试这些请求。一个幂等的系统保证了无论同一个请求被执行了多少次，而最终只生效一次（这里特指写入操作，译者注）。一个很好的例子就是支付系统。如果一个客户端请求付钱，操作成功之后由于请求超时客户端重新发起了这个请求，这时幂等的系统不会重复扣费。对于没有考虑幂等的系统，会重复扣费。</p>

<p>出于幂等的考量，分布式系统会引入某种形式的分布式锁策略。这是最早被引入分布式系统的概念之一。假设我们打算引入乐观锁（optimistic locking）来解决并发更新的问题。而为了实现乐观锁，又要求系统的强一致性，因为这样才能在操作时使用某种版本控制来检查是否有另外的操作在进行中。</p>

<p>取决于系统层面的约束和操作的类型，有很多实现幂等性的方式。设计如何实现幂等性是一个不错的挑战，Ben Nadel <a href="https://www.bennadel.com/blog/3390-considering-strategies-for-idempotency-without-distributed-locking-with-ben-darfler.htm">写了</a>他用过的不同策略，包括分布式锁和数据库约束。在设计分布式系统时，幂等性是最容易被忽略的部分之一，我的团队就因为没有确保某些关键操作正确的幂等性而付出过惨痛教训。</p>

<p><strong>为什么幂等性对于构建一个支付系统如此重要呢？</strong> 最重要的是：避免重复扣费和重复退款。前面提到了我们的消息系统确保消息至少被投递一次，可以想象所有消息都有可能被投递多次而系统就必须确保幂等性。我们最终选择了使用版本控制和乐观锁来解决这个问题，这个幂等性的系统则使用拥有强一致性的持久化存储作为数据源。</p>

<h2>Sharding 和 Quorum</h2>

<p>分布式系统通常会存储巨量的数据，超过了单个节点的能力范围。所以如何在一组机器上存储一批数据呢？最常用的做法就是 <a href="https://en.wikipedia.org/wiki/Shard_(database_architecture)">sharding</a>。数据基于某种哈希算法被水平的拆分。尽管大部分分布式系统的 sharding 策略都在底层，但 sharding 是一个学起来很有趣的领域，尤其是 <a href="https://medium.com/@jeeyoungk/how-sharding-works-b4dec46b3f6">resharding</a>。Foursquare 曾经在 2010 年由于一个 sharding 的边界问题导致了 17 个小时的宕机，之后有一篇<a href="http://highscalability.com/blog/2010/10/15/troubles-with-sharding-what-can-we-learn-from-the-foursquare.html">很棒的文章</a>分享了问题的根本原因。</p>

<p>许多分布式系统在多个节点上存储数据或进行计算。为了保证操作的一致性，一个基于投票的方案被发明，简言之必须有一定数量的节点都得到相同的结果操作才算成功。这个方案就是 quorum。</p>

<p><strong>为什么 sharding 和 quorum 对于构建一个支付系统如此重要呢？</strong> 这其实是分布式系统非常基础的两个概念。我个人在我们设置 Cassandra 复制策略的时候第一次遇到它们。Cassandra (或是其他分布式系统) 使用 <a href="https://docs.datastax.com/en/archived/cassandra/3.x/cassandra/dml/dmlConfigConsistency.html#dmlConfigConsistency__about-the-quorum-level">quorum</a> 和本地的 quorum 来确保集群的一致性。一个有趣的现象是，当我们开会的时候，一旦会议室有足够的人就有人会问：“可以开始了吗？我们有 quorum 机制吗？”（译者注，意思是并非所有人都在，大部分在也可以保证会议效果，和 quorum 一样 :D）</p>

<h2>Actor Model</h2>

<p>通常我们使用的一些编程词汇，诸如变量、接口、方法调用等等，都基于单台主机的系统（译者注，我觉得这里想表达的应该是单个进程内部，和后面的做对比）。当讨论分布式系统时，我们需要另外一种方式来表达。一种通用的描述这类系统的模型叫 <a href="https://en.wikipedia.org/wiki/Actor_model">actor model</a>，我们使用这个模型来描述系统间的通信。这个模型非常流行，是因为它和我们实际生活中的心智模型相匹配，比如人在一个组织中如何互相交流。而另外一个流行的模型叫做 <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">CSP</a> —— communicating sequential processes。</p>

<p>Actor model 基于 actor 如何相互发送信息和做出反应。每个 actor 被定义了有限的一系列行为——创造其他 actor，发送消息或是决定下一步的动作。只需要一些简单的规则，就可以很好的描述一个复杂的分布式系统，甚至在一个 actor 崩溃之后还能自我修复。我推荐 Brian Storti 的这篇 <a href="https://www.brianstorti.com/the-actor-model/">The actor model in 10 minutes</a> 作为简介。许多编程语言都实现了 actor model 的<a href="https://en.wikipedia.org/wiki/Actor_model#Actor_libraries_and_frameworks">类库或框架</a>，我们在 Uber 的一些项目中就使用了 <a href="https://doc.akka.io/docs/akka/2.4/intro/what-is-akka.html">Akka 工具包</a>。</p>

<p><strong>为什么 actor model 对于构建一个支付系统如此重要呢？</strong> 我们有很多工程师参与构建这个系统，其中很多人都有分布式系统的开发经验。我们决定遵循一种现行标准，而不是自己造轮子。</p>

<h2>Reactive 架构</h2>

<p>构建大型分布式系统的时候，目标通常是有弹性的、可伸缩的、可扩展的。可以是支付系统或是其他类似的高负载系统，可以使用相同的模式来实现这些目标。业内人士已经总结并分享了相关工作的最佳实践——而 Reactive 架构是其中最流行和广泛接受的。</p>

<p>想要快速了解 Reative 架构，我建议读读这篇 <a href="https://www.reactivemanifesto.org/">Reactive 宣言</a> 然后看一下这个 <a href="https://www.lightbend.com/blog/understand-reactive-architecture-design-and-programming-in-less-than-12-minutes">12 分钟的视频</a>。</p>

<p><strong>为什么 Reactive 架构 对于构建一个支付系统如此重要呢？</strong> Akka，也就是之前提到过的我们用来搭建支付系统的类库，深受 Reactive 架构的影响。许多我们的工程师对这套最佳实践也非常熟悉，所以遵循这些原则——响应式的、可伸缩的、有弹性的、消息驱动的——来构建这个系统变得非常自然。能有一种模型可以用来回溯和检查事情是否进展顺利是非常有用的，将来再构建新的系统我还会使用这个模型。</p>

<h2>结束语</h2>

<p>我非常幸运的有机会来重建一个及其关键的大型分布式系统：支撑 Uber 的支付系统。我接触到了许多之前不太熟悉的分布式的相关概念。所以我稍作总结，希望能对其他刚刚接触或者继续学习分布式系统的人有帮助。</p>

<p>这篇文章非常集中在如何设计一个系统的架构。还有很多事情可以讲，比如开发、部署、迁移以及如何可靠的运维这些系统。但这些话题需要其他的文章来描述。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[什么是做事专业]]></title>
    <link href="https://liangshan.blog/blog/2018/04/25/what-is-professional/"/>
    <updated>2018-04-25T17:53:35+08:00</updated>
    <id>https://liangshan.blog/blog/2018/04/25/what-is-professional</id>
    <content type="html"><![CDATA[<p>我们经常说某些人做事很专业，或者不够专业。当我们在使用专业这个词的时候，到底指的是什么？什么事情会让你觉得对方很专业？什么事情恰恰相反呢？</p>

<p>本文探讨的是我认为一个软件工程师如何做是专业的，而不是如何成为一名某个领域的专家。其他行业的应该也大体相通。</p>

<!--more-->


<h3>专业技能</h3>

<p>具备较强专业技能，这个是显而易见的前提，就不展开说了，主要想讨论其他方面。</p>

<h3>重视目标</h3>

<p>在公司做事是为了解决问题，不管专业技能多强都要有产出和结果。有的工程师大家一致认为能力不错也很聪明，但做出的东西总是出问题，这就不够专业。</p>

<p>顺便提到的就是谷歌著名的「20%时间」，即鼓励员工有20%的做自己事情的时间。我个人认为应该做一些公司能用的到的事情，不仅是因为对公司产生了价值，从个人角度出发，更快习得一项技能应该通过在实际项目中实践而不是对着文档写 Demo。</p>

<h3>遵守承诺</h3>

<p>专业的人非常慎重的承诺事情；专业的人能交付承诺的东西。</p>

<h3>滴水不漏</h3>

<p>专业的工程师做事滴水不漏，并且往往能够超出预期。</p>

<p>在做一件事情之前，专业的工程师除了要明确产出是什么，还要思考为什么要这么做？有没有什么问题？有没有更好的做法？做好之后，一定要把自己放到需求方的位置上思考，我交付的东西有没有达到要求，好不好用。不专业的工程师往往拿到任务就动手，交付之后经常会有小问题，一些问题是自己稍微用一下就显而易见的。</p>

<p>由于工程师一般处于需求的下游位置，接受需求的场景较多，所以如果需求方给到的需求很多漏洞甚至错误，需要工程师自己来补充很多细节，这个需求方就会给人留下很不专业的印象。反之，如果我们自己作为需求方让别人做某件事情，则需要尽可能的明确其中的输入和产出，以及可能遇到的边界条件和异常情况，这样是较为专业的做法。</p>

<p>值得特别提出的是，滴水不漏不仅仅是对外，对内也是如此。专业的工程师除了能交付商业价值，还对技术细节有着严苛要求。见过一些工程师交付的速度很快也都能正常使用，平时还很爱折腾新东西，按理来说爱折腾是一个工程师很好的表现，但仔细检查就会发现技术细节很差，为将来的维护埋下了隐患，这也是一种不够专业的表现。</p>

<h3>有效沟通</h3>

<p>对于工程师来说，有一个沟通渠道往往被忽视，就是文档。专业的工程师一定会编写文档。很多人对写文档有误解，认为写文档意味着浪费时间，意味着形式大于价值，但其实好的文档一定会帮助所有人。</p>

<p>沟通的另外一个问题就是态度，时刻保持一份谦虚和对别人的尊重会给人专业的感觉。另外提出问题的同时要给出解决方案，会让对方感受到你的专业。我个人非常反感只会挑问题的人。</p>

<p>有效沟通意味使用正常的音量和正常的语气沟通；有效沟通意味着描述一件事情应该从宏观到微观，先把事情的背景交代清楚，保证参与沟通的所有人在同一个与语义环境下，再描述细节。</p>

<h3>最佳实践</h3>

<p>之前的滴水不漏主要是强调要站在需求方的角度思考自己做的事情是不是专业，这里主要想讨论到具体执行的过程。</p>

<p>我们日常的工作中，绝大多数事情都是别人解决过的问题，所以解决问题之前先思考类似的事情有没有最佳实践是非常专业的做法。最佳实践包括了知识获取、解决方案、解决步骤、呈现方式等等，是完成某种事情的方法论。</p>

<p>举例来说，文档中的流程图应该如何画算是最佳实践呢？理论上你可以找到任意能够画出流程图的工具来画，然后把图片上传到文档中。但这样如果流程图有更新，则需要重新生成图片重新上传。所以对于工程师来说，可以尝试使用代码来画图，这样更新只要改源代码即可;使用版本控制来管理这些代码还可以看到版本的变化;任何人拿到这个代码都可以还原出一模一样的流程图，也方便了相互协作。</p>

<p>专业的工程师善于从自己做过的事情中整理出最佳实践。</p>

<h3>总结</h3>

<p>这些专业和不专业的细节也都是从我身边的人身上总结下来的，和专业的人工作是充满乐趣的，能从他们身上学到很多东西。</p>

<p>希望自己和身边的人都能专业一点。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[认真学习阿里双11的技术]]></title>
    <link href="https://liangshan.blog/blog/2018/02/14/learn-from-ali-double-11/"/>
    <updated>2018-02-14T13:45:51+08:00</updated>
    <id>https://liangshan.blog/blog/2018/02/14/learn-from-ali-double-11</id>
    <content type="html"><![CDATA[<p>难得过年没有请假，有时间整理一下前几天看了别人转发的，关于阿里双十一的一些技术总结。原文应该叫「互联网技术超级工程」，有兴趣的可以去互联网上搜索一下，应该是免费提供下载的。</p>

<p>那些开源软件的升级版、定制版我就直接略过了，确实是要到一定规模才会遇到的问题，现在看也看不懂。说一些我觉得有意思的地方吧。</p>

<!--more-->


<p>之前在安居客我也做过搜索，优化过很长时间，方向就是语义化(semantic)。简单来说，除去文本匹配之外试图理解用户更深层的意思。比如，如果用户搜索「近期好看的电影」，机器如何理解「近期」呢？阿里的做法是通过 query 品类预测、query 改写，可以得出「近期好看的电影」和「2018年好看的电影」相似度较高。首先是品类预测，每次查询之后的点击转化都会用于学习这次查询中的词和品类之间的关系。然后再通过 DSSM 来猜测和这个 query 接近的其他 query。同样使用 DSSM 可以训练物品之间的相似度、物品标题和物品内容的匹配度(引用原文说法：「可以一定程度上遏制淘宝商品标题堆砌热门关键词的问题」。</p>

<p>阿里有很多活动，每个活动都有很多细则，以及问答知识库。以往都是人工来生成这些问答，但其实这些答案都是从细则中来的，所以可以尝试使用机器学习来做「阅读理解」，自动从活动规则中找到用户想要的答案。这个思路很酷，具体流程：</p>

<p><img src="https://liangshan.blog/images/custom/arch-auto-answer.png" /></p>

<p>另外文章中多次提到了 A/B 测试的结果，大促期间确实是一个有足够数据来测试想法的好机会。</p>

<p>最后想提一下混部技术。简单来说，业务有高峰波谷，能不能在闲时自动调度一些其他任务过来执行？</p>

<blockquote><p>很多人都被车堵过，而堵车的时候，并不是所有的车道都在堵车。有一个比较
有趣的情况，我们称之为潮汐现象，而它造成的问题是在早高峰的时候是进城方向堵
车，而晚高峰是出城方向堵。而为了缓解这个问题，我们使用了潮汐车道的方式。
那么同样的原理，是否如果能让这两个集群混合起来部署，让计算任务的一部分
任务跑到在线服务的资源之上，把在线服务空闲的资源利用起来呢？答案是肯定的。</p></blockquote>

<p>需求很简单，但做起来就非常难了。有多难呢？以阿里的人力物力，做了 4 年才落地，2017年的双11有 20% 的流量跑在混部的机器上。因为这里面的基础设施太复杂，首先不同的应用需要跑在自己完全隔离的环境中，还要实现闲/忙时段的自动调度。但这样的大工程一旦启用，就会发挥巨大的价值，据发明这项技术的 Google 透露，可以节约 30% 的服务器资源。</p>

<p>老实讲看完了第一个感受就是，这得有多少个工程师啊。一直以来我的想法就是人招少一点，招好一点，这样这批人无论做什么都能搞定。但看完这个介绍之后，你不得不承认在某一个领域堆砌人才确实可以把深度做的足够深。举个例子，「发红包」应该是现在促销的常规手段了，一般的做法无非就是人为定一些规则，让用户来领或者抢。但双11的红包背后居然有一整套的机器学习模型来支持：</p>

<blockquote><ul>
<li>消费者双 11 当天消费金额预估—根据预估的消费金额，计算消费者需要的购物津贴，确保购物津贴有稀缺感的同时，最大化的促进成交</li>
<li>消费者优惠敏感度分析—对于不同的消费者，发放不同金额的红包，在保证使用率的同时，可以惠及更多的消费者。</li>
<li>消费者传播力分析—在火炬红包活动中，可以给高传播用户更高获取未点亮红包的概率，以触达、传播更多的用户。</li>
<li>消费者类目偏好分析、流失分析—用于产出需要重点关注的人群（比如“偏科”人群、流失人群、光看不买人群），可以发放特定的红包提升用户转化。</li>
</ul>
</blockquote>

<p>佩(zhen)服(xian)。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记一次性能调优]]></title>
    <link href="https://liangshan.blog/blog/2016/09/12/the-law-of-leaky-abstractions/"/>
    <updated>2016-09-12T14:35:18+08:00</updated>
    <id>https://liangshan.blog/blog/2016/09/12/the-law-of-leaky-abstractions</id>
    <content type="html"><![CDATA[<p>继上次做性能优化之后，再次针对我们刚刚全新升级的 app 做了一轮性能调优，而这个过程又引起了我一些思考，这里做一个记录。</p>

<p>根据多年的经验，性能问题一般都是由后端服务引起，API 服务器忙都是受后端服务的拖累所表现出来的现象。所以一入手就是监控各个后端服务的运行情况，初步定位瓶颈在数据库上。第一步就是趁着业务上将来要做全文检索，使用搜索引擎代替数据库作为列表的数据源。这个优化上线之后，高峰时数据库压力有了明显改善。然而这个改善并没有表现在前端页面的速度监控上，几乎所有页面都非常统一的在某些时间点会有长至几秒钟的响应时间，发生的时间间隔没有明显规律，大概几分钟一次，每次持续十几秒钟，并且这些异常并不跟我们的业务高峰有重合。</p>

<p>当时的猜测有 2 个，一个是仍然有什么慢查询影响了整个数据库的性能，从而影响了整站的性能。另外一个是某台机器有问题，所以所有落在那台机器上的请求都会变慢。要验证第二点是非常简单的，我单独拿了一台机器去独立运行最简单的一个业务，结果显示并没有什么变化。</p>

<p>再次确认 API 机器没有资源瓶颈的前提下，决定在代码里埋点统计执行时间，发现了一些执行很慢的代码块，慢的时间和那些异常时间也吻合，只是执行时长对不上。刚才提到异常时刻的响应时间以秒计算，这些慢查询最慢也就是几百毫秒，不在一个数量级。第一感觉就是也许这些慢查询累加起来就会将危害放大。总之优化这些地方最起码不是错误的，于是着手把这些找到的点都修正掉了。</p>

<p>然而那些监控图表上的毛刺像一根根的针一样依然存在，并且由于做了几轮优化，高峰和低谷的对比更加明显，这些图看起来就更诡异。</p>

<!-- more -->


<p>针对每个页面都有同样表现这个特点，我想到了会不会是代码的中间层有问题。框架总会提供一些方案来给开发人员在执行业务代码之前统一做一些事情，比如权限检查、登录检查等等。如果是这里有问题，可以解释为什么所有页面都受影响。同样做埋点和统计，发现了某个中间层代码存在的慢查询，这次异常的时间和时长都对应的上。于是很高兴的做了优化，然后上线。</p>

<p>结果仍然没有什么改变，最不可思议的是异常代码块似乎会「转移」，现在转移到一个最简单的主键查询上。</p>

<p>当时刚好是午饭时间，带着郁闷的心情去吃了寿司，边吃饭边思考，这些所有看到的现象是不是都仅仅是现象，而不是根本原因？为什么出现在中间层？为什么会转移？突然我意识到或许是建立连接很慢，哪里第一次建立连接哪里就慢，之前优化中增加了缓存所以慢的代码发生了「转移」。</p>

<p>有些假设你第一次想到的时候就知道是对的，就像你上学时候做出的物理题结果一看就知道对错，正确的东西带有一种独特的气息。</p>

<p>下午回去就做了一个实验，在应用程序刚开始运行的时候就执行一段数据库查询。结果印证了我的假设，异常代码块「转移」到了新加的实验代码上。那么在建立连接的时候到底发生了什么呢？于是在生产环境抓包，在本地来做分析。通过比对正常时间和异常时间 TCP 包的内容，发现每次异常期间，就会有大量的 <code>use db</code> 语句卡住。说实话刚刚确认这一点的时候我觉得非常惊讶，因为从来没有想过这个会有问题。为了避免是某种语言或者特定框架的问题，我单独写了一个 shell 脚本做测试，结果显示和线上代码反应的结果一致。</p>

<p>我们使用的是阿里云服务，联系了他们的技术支持，虽然仍然不知道什么导致了 <code>use db</code> 的问题，但最终通过切换实例的可用区解决了现象，应用程序终于可以平稳运行。</p>

<p>在这个曲折的过程中，我想说的是，解决不了问题的时候，吃顿好的还是非常有用的。</p>

<p>好吧，我认为在特定的时刻允许工程师直接到线上调试是非常重要的，设想如果每次想验证想法都要等上线，整个调试过程的连续性和有效性都无法得到保证。但是我依然坚持线上调试需要至少两个人以结对编程的方式进行。</p>

<p>后来，我把这个事情和之前的同事分享。他提到一个词，也是这篇文章的英文标题：抽象泄漏。有兴趣可以去看他 <a href="http://shzhangji.com/blog/2013/12/17/the-law-of-leaky-abstractions/">翻译的原文</a>，这里只做摘录，其中的观点非常有趣。</p>

<blockquote><p>这就是我所说的“抽象泄漏”。TCP协议试图提供一个完整的抽象，将底层不可靠的数据传输包装起来，但是，底层的传输有时也会发生问题，即便是TCP协议也无法解决，这时你会发现，它也不是万能的。TCP协议就是“抽象泄漏定律”的示例之一，其实，几乎所有的抽象都是泄漏的。这种泄漏有时很小，有时会很严重。</p>

<p>由于抽象定律的存在，每当有人说自己发现了一款新的代码生成工具，能够大大提高我们的编程效率时，你会听很多人说“先学习手工编写，再去用工具生成”。代码生成工具是一种抽象，同样也会泄漏，唯一的解决方法是学习它的实现原理，即它抽象了什么。所以说抽象只是用于提高我们的工作效率的，而不会节省我们的学习时间。</p>

<p>这就形成了一个悖论：当我们拥有越来越高级的开发工具，越来越好的“抽象”，要成为一个高水平的程序员反而越来越困难了。</p></blockquote>

<p>具体到我们这个案例里面，至少有 2 处抽象泄漏。首先，数据库连接层将如何连接数据库抽象出来，将登录数据库和切换数据库的行为隐藏起来，对于程序员来说，只需要初始化一个数据库连接对象就会做掉这 2 件事情，所以一开始我会误以为是数据库连接问题，而其实是切换数据库时才会有问题。其次，更要命的抽象泄漏就是云服务，云服务带来很多便利，然而一旦服务出了问题，就非常难以定位和解决，且不说定位就花了一周时间，单单从确认是阿里云的问题开始到最终解决就花了 4 天时间，而这个就是「抽象泄漏」一文中很重要的观点：</p>

<blockquote><p>十年前，我们会想象未来能够出现各种新式的编程范型，简化我们的工作。的确，这些年我们创造的各类抽象使得开发复杂的大型软件变得比十五年前要简单得多，就像GUI和网络编程。现代的面向对象编程语言让我们的工作变得高效快速。但突然有一天，这种抽象泄漏出一个问题，解决它需要耗费两星期。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网站性能优化之外]]></title>
    <link href="https://liangshan.blog/blog/2016/07/18/beyond-tuning-performance/"/>
    <updated>2016-07-18T16:36:21+08:00</updated>
    <id>https://liangshan.blog/blog/2016/07/18/beyond-tuning-performance</id>
    <content type="html"><![CDATA[<p>前段时间在做我们内部一个业务的性能优化，过程里有些感想，这里记录一下。</p>

<p>略去具体的技术手段，我想到的其实超出了性能优化的范畴。</p>

<p>首先，优化上线之后引起了 2 个 bug，一个是重构之后某个代码分支没有测试到，另外一个是某处改动同时被其他页面引用，所以影响了该页面。
这印证了我一直以来的想法，写测试代码看似花了额外的时间，其实节省的都是将来修改 bug 的时间。如果没有这些测试代码，怎么有自信去不停的改进？</p>

<p>其次，在整个调优的过程中，我一直在想如果这些代码经过充分的讨论以及 Review，可能就不会被带到线上。因为一些是明显的慢查询，以及一些相关设计上的缺陷。所以 Code Review 看起来同样花了额外的时间，其实节省了将来重构的时间。</p>

<p>其实这两件事还可以结合起来看，没有 review 没有测试代码，或许在暗示工程师可以写烂代码，反正只要项目上线之前测试工程师能通过就可以了。</p>

<p>团队最怕的就是「内耗」，在这次优化过程中，我花了大概一个礼拜的时间。首先把性能数据可视化，以便能直观的看到优化效果，然后了解业务、分析代码，最后动手优化，前后改进了 3 个版本。我认为这已经是某种程度的内耗，因为原本可以做更有意义的事，但花了一个星期来做一些经过工程方法可以避免的事情。</p>

<p>另外想到的一个问题是，我们总是要平衡设计和施工速度。现在互联网公司的趋势是强调施工速度，而刻意避免过度设计。我也反对过度设计，但这并不等于什么都不管先实现再说。反对过度设计并不能成为自己写烂代码的借口。作为一个设计者，要知道哪些东西是「覆水难收」，哪些东西要留足可扩展性。而几乎任何时候，保持低耦合都是很重要的原则。</p>

<p>最后我想说的是，重视招聘和工程师文化的建设，或许这才是解决问题的根本。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多做一点点]]></title>
    <link href="https://liangshan.blog/blog/2016/01/25/do-a-little-more/"/>
    <updated>2016-01-25T13:53:59+08:00</updated>
    <id>https://liangshan.blog/blog/2016/01/25/do-a-little-more</id>
    <content type="html"><![CDATA[<p>自从决定 <a href="https://liangshan.blog/blog/2014/09/09/huan-ge-zi-shi-xie-bo-ke/">换个姿势写博客</a> 之后，发现可写的内容越来越少了。</p>

<p>这次讲一个鸡汤故事。</p>

<p>故事要从我刚加入安居客说起，那时候刚刚加入一个相对有规模的团队，对身边的一切都充满着好奇，也折腾点东西。其实现在看来都是一些小儿科的东西，甚至有些是在重复造轮子，质量也不怎么样。但是凭着一股热情，还是打动了团队领导，把我介绍给 <a href="https://github.com/erning">尔宁</a> 认识，跟着学点东西。大概是 2012 年的春天，尔宁说我们找个人翻译一下 <a href="http://12factor.net/">12 factors</a> 吧，要么你来搞一下，业余时间弄一下就行。</p>

<p>当时还有另外一个工程师翻译的 <a href="https://github.com/anjuke/zguide-cn">ZeroMQ 文档</a> ，跟那个一比，才 12 页内容。我就说没问题。</p>

<p>我忽略了一个问题，把话写的短一点更难。这 12 条原则是高度抽象的，我当时的水平其实至少有一半都看不明白，里面举例使用的工具和软件也都没用过。12 页内容，我至少翻译了 1 个月。最后经过同事帮忙校对，放到 github 上，我自认为算是完事了。</p>

<p>但之后我慢慢发现，工作中遇到的几乎所有问题都能在 12 factors 里面找到答案，甚至每次回顾都能理解以前不懂的部分，所谓的「温故而知新」。于是我又重新整理了一遍翻译，watch 了这个项目（之前只有 star）。</p>

<p>不久之后收到提醒有一位日本的工程师提交了一个 PR，实现了对多语言同时在线的支持。我也依葫芦画瓢把简体中文版的提交了 PR，然后就被合并了，也就是现在看到的 <a href="http://12factor.net/zh_cn/">简体中文版</a>。顺便说一下，经过社区的贡献，现在 12 factors 有 11 种语言的版本。</p>

<p>之后基本上每个月都会收到邮件咨询一些 12 factors 的事情，直到有一天收到一封 O&#8217;reilly 编辑发来的邮件，内容大概是说 12 factors 太抽象了，他要写一本书扩展一下，找我是让我帮忙校对内容，主要是提提意见。作为回报我可以得到任意 2 本 O&#8217;reilly 的书籍，实体书或者电子书都可以。</p>

<p>以前都是 review 代码，这次有机会 review 别人写的书，另外英文原本的书至少也要 200 刀了。<del>为了这些钱</del>，我爽快的答应了。</p>

<p>每次工作累了，就拿书稿出来看一部分，这样断断续续两个礼拜也就弄完了。很快 2 本电子书就按照我的要求被打入了我 O&#8217;reilly 的账户。</p>

<p>这就是我当时只是答应多做一点点事情的结果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入实践 SOA 架构]]></title>
    <link href="https://liangshan.blog/blog/2015/06/21/dive-into-soa-architecture/"/>
    <updated>2015-06-21T22:16:05+08:00</updated>
    <id>https://liangshan.blog/blog/2015/06/21/dive-into-soa-architecture</id>
    <content type="html"><![CDATA[<p>之前介绍了<a href="https://liangshan.blog/blog/2014/11/03/how-to-choose-rpc-framework/">如何选择 RPC 框架</a>，选择 RPC 框架是实施 SOA 的重要一步，但也仅仅是第一步。今天来讨论具体实施 RPC 过程中，遇到的一些细节。</p>

<p>写下第一个真正的 RPC 服务，首先遇到的问题就是服务划分，或者叫服务的分层。当然最简单的就是不分层，把所有的接口都写在一起，即当服务启动的时候所有的接口都被载入内存从而被访问。现如今软件架构的趋势是使用分布式的独立的微型服务（Micro Service）搭积木，SOA 正是实现这一构想的途径之一，但如果不给服务做划分显然和初衷背道而驰。我们最终选定的划分方式是按照业务（Domain）首先划分出基础服务，我们称之为 LEVEL-1，跨基础服务的接口称之为 LEVEL-2，一些与商业无关的，更为通用的模块称之为 LEVEL-0。</p>

<p>这里以淘宝为例，列举几个服务分层的例子：</p>

<p>LEVEL-1：买家，卖家，账户，商品，交易</p>

<p>LEVEL-2：用户购买一个商品，需要读取账户信息（余额、银行卡），需要读取商品信息（价格、运费），成功后产生一条交易记录。横跨了几乎所有 LEVEL-1 服务，显然是在 LEVEL-2 了。理论上讲 LEVEL-1 的服务各种组合都会产生一个 LEVEL-2 服务。但我的经验是，可以先把所有的 LEVEL-2 都写在一起，等到一些组合十分明确的时候再拆出去。</p>

<p>LEVEL-0：国际化和本地化的一些需求（地理位置，汇率，多语言），敏感词过滤等等，这些服务的特点是都被 LEVEL-1 依赖，又和核心商业逻辑关系不大。</p>

<p>同时围绕这 3 层服务，有一个原则：只能自上而下调用，不可自下而上掉用，同时不可同级应用之间调用。这里指的调用是 RPC，而不是代码上的依赖和调用。</p>

<p>解决了服务划分的问题，在架构设计时同样应该考虑开发、测试、运维。先简单说开发和运维，使用 Ansible + Vagrant 可以保证开发环境的一致性，以及开发环境与生产环境的一致性。在开发环境配置阶段，会将 SOA 的客户端和服务端都部署在同一个虚拟环境里。同时在开发新项目的过程中，不可避免的需要更新数据库，我认为更新数据库的代码也应该是整个项目的一部分，即数据库的变更也应该体现在版本控制中，这个非常重要，这是最终上线前准备工作的重要一环。不同语言的 ORM 都提供了 Migration 工具，但由于 SOA 是跨平台跨语言的，所以我选择了将每一次 Migration 都转化为 SQL 文件，提交到 Ansible Playbook 的仓库，由 Ansible 在部署过程中自动生效。</p>

<p>下面重点说说测试，我们没有专职的测试人员，使用 TDD + Code Review 的方式来保证软件交付的质量，基本上的要求是所有接口都应该是先写测试代码再写实现代码，Review 过程中至少 2 个 Reviewer 通过才可以合并。随着对 TDD 的理解不断加深，我目前所理解的测试代码大概分为两个层面：单元测试，集成测试。</p>

<p>单元测试是指代码中原子性的方法。单元测试遇到其他系统依赖，比如发送邮件，往往需要 mock 这些方法，只是模拟这些方法在特定输入输出下的行为是否符合预期，并非真正的发出邮件。在我所设计的服务分层中，LEVEL-2 测试调用 LEVEL-1 也同样需要 mock，而不是真的启一个 LEVEL-1 的服务用来单元测试。这里需要特别指出的是，严格意义上来讲数据库也是外部依赖，但 <code>SQLite</code> 几乎都预装的前提下，我们可以模拟出一个比较真实的测试环境，所以一般来讲现在都可以真实的操作数据库而不是 mock 方法的返回值了。每次测试前创建数据表及测试数据，测试后再清除所有内容，这是单元测试的标准流程。</p>

<p>集成测试是指将整个系统的各个组件真实的组建起来做统一的测试，还以发送邮件为例，集成测试就需要真正的触发发送邮件的动作。由于我们开发的是 Web 应用，所以我们选择使用 <a href="https://en.wikipedia.org/?title=Acceptance_testing">User Acceptance Testing</a> 来做集成测试。简答来说就是借助浏览器，或是可以执行 JavaScript，CSS 的服务端软件，来模拟用户行为，将网站所有功能点都使用一遍与预设的输出来对比。这里有几个问题要解决：
第一，和单元测试一样，每次测试使用的数据要重置，要预留测试需要用到的测试数据。
第二，与单元测试不同的是，测试数据不仅仅为特定的方法准备，而是需要完整的，足以支撑整个网站运行的数据。
第三，由于 SOA 架构，客户端和服务端需要在测试期间连接同一个测试数据库。
为了解决以上的问题，利用 Ansible 给每个开发环境的虚拟机都部署了一个专门用来做集成测试的数据库，以及集成测试专用的配置文件（主要是数据库连接）。另外给集成测试的命令加了一些 wrapper ：重置数据库、导入准备好的测试数据（为了保持数据之间的关联，我直接从线上 dump 下一小部分）、切换至测试专用配置文件（包括客户端和服务端）、执行集成测试、切换回正常配置文件。</p>

<p>至此，在 SOA 实践中遇到的一些问题都得到了比较好的解决。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[选择是一种能力]]></title>
    <link href="https://liangshan.blog/blog/2014/12/24/choosing-is-an-ability/"/>
    <updated>2014-12-24T16:28:05+08:00</updated>
    <id>https://liangshan.blog/blog/2014/12/24/choosing-is-an-ability</id>
    <content type="html"><![CDATA[<p>今年从不同的几个人嘴里都说出了一句话：『有时候选择比能力更重要』。第一次听见这句话，感觉说对了一半：想要有很多选择，首先需要有很强的能力才行，另外选择的过程本身就是一种能力的体现。这 2 个月的经历更让我坚信了这一点。</p>

<p>10 月份开始动了想换工作的念头，先说说为什么想换工作。其实我之前的工作可能在一些人看来是非常完美的，甚至是很多工程师的理想环境：公司的纯技术部门，简直是技术部的特种部队，可以按照自己的想法来实践方案，受到很多工程师和领导的尊重。</p>

<p>但我却感觉越来越不舒服。</p>

<p>我的技术哲学是，不仅要不断学习，更要实践。当时的实际情况是，我们几个想要推行一些新的实践时最后的结果往往是变成小范围的玩具。因为公司几年已经积累了太多工具和代码，基本上该有的都有了。好用不好用是一个问题，但起码够用，所以公司对于改进底层技术的意愿远没有说的那么强烈。这时我想起有人说重构的一个目的就是让工程师开心，这下我彻底接受这个观点了。</p>

<p>有时候太安逸真的是一个问题，对于公司如此，对于我来说更是深知这份「美差」不是好事。</p>

<p>几经面试，有了几个选择，而对方愿意给我机会还是因为我在架构部门的独特经历。同时公司也给出了足够的诚意来挽留我，给了新的部门和薪水。在这个过程中，我仍然相信是能力带来了选择。</p>

<p>在得知我在找工作后，有位前辈好心教导我，应该去大公司待几年，刷刷身份，前途无限。或许他是对的，但我想如果是那样，和我留下又有什么区别？除了可能公司名字更加响亮，可以认识更多的技术人之外，「大公司毛病」我想大同小异。得益于身边的几位同事，我对于所谓的大型架构和大牛早已看透了，选合适的方案解决问题而已，我想要的氛围是 &lsquo;<em>Move fast and breaking things</em>&#8216;，这句是来自 Facebook 的名言。说句题外话，GitHub, Google 或者 Facebook 当然是非常有吸引力，但似乎离我还有点遥远，压根也就没考虑。有人能帮我过去一定让我知道，千万别客气。</p>

<p>这时现在的公司出现在我的选择里，看起来很奇怪的公司。</p>

<p>是跨国公司，但又是初创公司；是互联网公司，却还没有自己成型的研发团队；团队的中国人都会讲英文，团队的老外几乎都会讲中文。兼职和外包是当时工程师的主要来源，这些为公司干活的工程师在世界各地，他们用 slask 交流，用 GitHub 托管代码，用 AWS 托管服务器，用 jira 来管理项目，用 xbox 在办公室踢 fifa，用 CEO 戴假发在球场当拉拉队。</p>

<p>一直以来，我坚持认为公司的技术部门应该走精英化路线。
第一，写代码说到底还是创造性劳动，效率和质量与人的能力不是线性关系，我觉得应该接近于指数。
第二，精英喜欢且只喜欢与精英一起工作。
第三，公司不需要因为开展新的业务而大量招聘，举例来说一个传统网站想要开展新的移动业务，只需要找到一个有丰富实践经验的人，就可以让所有人都变成 iOS/Android 开发工程师，因为精英乐于接受新的挑战。
第四，最重要的一点，精英基本不需要管理，只要给一个大家都认可的方向即可。</p>

<p>这里唯一的问题是精英难找，不过只要找到第一个，只要让他认可你的观点，就一定能找到第二个、第 N 个。在公司达到一定规模时，可以去学校招一些优秀的毕业生。这只是我的想法，没有实践过，比如说公司正在迅速成长，一下子哪来那么多精英可招？我认为精英比例虽小，但找几个满足一家公司的需求还是不难的吧？就看你有没有决心，有没有诚意。</p>

<p>一些迹象表明这个团队有希望成为我想象的那样，几经交谈，我决定加入这里。</p>

<p>让我们再从头看一次整个过程。安逸和挑战，我选择了挑战；去上市公司、留守、创业外企，我根据自己的内心做出了选择。由于这些年的积累获得了这些选择，而这些选择本身代表了我对于技术和事业的理解。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Choose RPC Framework]]></title>
    <link href="https://liangshan.blog/blog/2014/11/03/how-to-choose-rpc-framework/"/>
    <updated>2014-11-03T15:16:21+08:00</updated>
    <id>https://liangshan.blog/blog/2014/11/03/how-to-choose-rpc-framework</id>
    <content type="html"><![CDATA[<p>RPC 是 remote procedure call 的缩写，意指调用远程进程的方法。这里的远程需要广义的理解，有时为了协议的统一即使调用本地进程也叫做 RPC，所以 RPC 可简单理解为进程间通信。</p>

<p>在选择 RPC 框架之前，要搞清楚为什么需要 RPC？ RPC 主要是为了解决服务化架构中客户端与服务端以及服务之间通讯的问题。在最早接触 RPC 的时候，我一直有一个疑问： RESTful API 不就搞定了么？为什么需要 RPC？直到深入实践了 RPC，我自己总结了 RPC 与 RESTful API 最大的几个不同。</p>

<!-- more -->


<p>首先，RESTful API 经常纠结的问题就是，到底在什么样的资源粒度上开放接口？到底需要哪些接口？而在 RPC 中这个问题被很大程度上淡化了，因为 RPC 使用起来几乎和本地方法没有太多区别。</p>

<p>其次，RESTful API 在应用层使用 HTTP 协议，这使得传输数据受到限制，实践中早些年流行过 xml，现在 JSON 应该是标准做法了。但这些在大量读写时，都会消耗较大的流量，构造这些结构必然消耗额外的带宽。而 RPC 的协议都是由各框架自己定义的，目前还没有形成标准，以 Apache Thrift （以下简称 Thrift）为例，使用二进制的编码大大降低了数据大小。</p>

<p>最后，也是我认为最重要的区别， RPC 可以实现异步请求，而受限于 HTTP 协议的 RESTful API 则无法实现这个功能。而异步请求让整个请求过程变得非阻塞，比如在一个 PHP 进程中将互不依赖的几个数据请求变成异步执行，这样执行时间取决于最慢的请求而不是它们相加。</p>

<p>基于以上 3 点，我们非常确定需要选择一个 RPC 框架，比较流行的有 Thrift, Google Protocol Buffer, Avro。我将它们归为一类，并以 Thrift 为代表。但我倾向于另外一个选择：基于 ZeroMQ 和 Msgpack 的 ZeroRPC。下面以 Thrift 和 ZeroRPC 的对比来解释我的选择，这些对比并不涉及易用性或者安全性，仅仅从核心的信息传递角度来比较。</p>

<p>在 RPC 框架中，最重要的 3 个核心组件： transport，protocol，encoding。</p>

<p>Transport，即传输方式。Thrift 使用 socket，而 ZeroRPC 使用 ZeroMQ —— 一个丰富扩展过的 socket 类库。在传输方式的灵活性上，ZeroRPC 明显胜过一筹。</p>

<p>Protocol，即通讯协议。Thrift 使用自己定义的 Tprotocol，协议并不复杂，以 byte 长度来规定消息格式。比如前 4 个 byte 来表示状态码。而基于 ZeroMQ 的扩展， ZeroRPC 可以使用消息帧（Frames）来构建更加灵活的通讯协议。</p>

<p>Encoding，即序列化或简单理解为数据压缩。Thrift 的文档中并没有透露过多关于序列化算法的细节，而 ZeroRPC 使用 Msgpack 作为序列化/反序列化的工具。 Msgpack 本身是一个优秀的开源项目，功能更加强大。</p>

<p>除了以上 3 个维度，我认为 ZeroRPC 还有另外一个明显的优势，ZeroRPC 是由 2 款开源软件组合而成，这意味着可以灵活的替换为其他类似的组件。比如 nanomsg 来替代 ZeroMQ，只要 SDK 封装的足够抽象，可以无缝的切换类库。</p>

<p>说了这么多，其实 ZeroRPC 最大的优势就是 ZeroMQ，给 socket 加上了更加丰富的可能性。但 ZeroRPC 没有提供 PHP 的客户端，我可能需要根据它的协议来自己构建一个。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[到底什么是产品经理]]></title>
    <link href="https://liangshan.blog/blog/2014/09/10/what-is-product-manager-exactly/"/>
    <updated>2014-09-10T14:13:28+08:00</updated>
    <id>https://liangshan.blog/blog/2014/09/10/what-is-product-manager-exactly</id>
    <content type="html"><![CDATA[<p>不知道有多少人和我一样，即使在互联网公司工作了很多年，还是没搞清楚「产品经理」到底是什么样的一个职位。我甚至特意看过很多关于产品经理的文章，仍然没有搞清楚这个问题。而在工程师的圈子里，弥漫着对产品经理的各种，恩，各种情绪。上篇文章说了，我要用自己的大脑思考取得结论，到底什么是产品经理？</p>

<!-- more -->


<p>我承认在念这个疑问句的时候，想要某些位置加几个屏蔽词来着，因为这个问题实在是难以回答。我估计甚至大多数产品经理自己也很难说清楚，今天我要来完成这个挑战。</p>

<p>其实写下这一行的时候我还没有确切的思路，只有一些零星的想法，看看能否边写边整理出答案。</p>

<p>上面说过我看了很多关于产品经理的文章，这些文章大多数是产品经理们自己写的，无一例外的把笔尖对准了「怎么做一名好的产品经理」，描绘了一副美好的产品经理蓝图。但读完其实更糊涂了，因为跟我感受到的差距很大。我们能否从另外一个角度来寻找答案，如果现在公司里没有产品经理将发生什么？这样没人做的事或者是其他人应该多做的事，是不是可以大致理解为产品经理的工作？从这个思路出发，我先试着往其他几个角色上套，注意这里说的「角色」，而不是职位。比如我们都知道软件需要测试，但并不是每个公司都有测试工程师这个职位。</p>

<p>如果没有开发工程师，即便假设最优的情况：所有现有项目都没有 BUG，不出现不可抗力程序不会挂掉。公司新的想法也无人实现，公司将静止在最后一次上线的那一刻。</p>

<p>如果没有运维工程师，我们仍然假设最优的情况：所有现有机器上的资源针对现有业务都很充裕，做了很好的策略保证流量稳定，磁盘不会被写满，不出现不可抗力机器不会宕机。那么新的项目仍然无法上线，因为那会打破现在资源的平衡，与没有开发工程师的结局类似。</p>

<p>如果没有测试工程师，可能会很糟，甚至比什么不做还要遭，但也可能由于高超的开发技巧避免了严重的问题。（<em>但无论如何，我认为专门的测试工程师应该认真思考自己的未来。</em>）</p>

<p>如果没有公关部，公司可以少做发一些奇怪的虚假软文。</p>

<p>如果没有 HR，恩，可以不听公司的广播。</p>

<p>看来这个思路可行，很好的分析了各个角色的作用，代入产品经理试试看。</p>

<p>如果没有产品经理，老实讲这个逗号之后我停留了很久，但思考的结果让我震惊。震惊的原因是，既不是完全没有变化，也不是每个人都会产生变化。没有产品经理之后，最忙居然是开发部门！</p>

<ul>
<li>销售、运营、市场部门、Boss 有需求将直接找到开发部门</li>
<li>需求文档将由开发部门自己完成，当然可以由需求方提供详细的逻辑，但开发显然更合适</li>
<li>开发必须和视觉设计师密切工作</li>
<li>有些没有需求方的项目，开发需要自己完成不断的迭代。比如搜索或推荐系统的应用。</li>
</ul>


<p>从这里也可以看出，<strong>产品经理日常的工作主要是收集需求、设计逻辑、和视觉设计师一起确定样式、创造一些新的产品、迭代一些现有的产品</strong>。工作内容整理清楚了，看起来还不错。那么接下来主要来分析开发工程师对产品经理的情绪从哪来。</p>

<ul>
<li>从上面的列表其实可以发现，产品经理的产出是文字，而写字人人都会</li>
<li>逻辑每个人都会设计，有人说「人人都是产品经理」，老板们往往称自己是「产品」</li>
<li>经常给老板们汇报工作，跟高层更接近，当然看起来比工程师高大上</li>
<li>经常假借迭代之名，折腾很多没意义的项目。不服的看看新浪微博。</li>
</ul>


<p>总结一下就是，这帮人动动嘴皮子，写点作文，画画流程图，每天除了开会就是在去开会的路上，公司完全可以不需要 TA 们。居然还跟老板混的熟，看起来比我精通 5 门编程语言、倒背算法导论的天才开发还要重要！这不科学！</p>

<p>前面说过了，我写这篇文章就是因为自己也没有完全想清楚，但确定觉得并不是上面列的那样，因为这个职位每个公司都存在一定不是巧合。那么我们反过来想，假设在没有产品经理的年代里，这个角色是如何在公司里产生的？</p>

<p>我们不妨再看一遍：</p>

<blockquote><ul>
<li>销售、运营、市场部门、Boss 有需求将直接找到开发部门</li>
<li>需求文档将由开发部门自己完成，当然可以由需求方提供详细的逻辑，但开发显然更合适</li>
<li>开发必须和视觉设计师密切工作</li>
<li>有些没有需求方的项目，开发需要自己完成不断的迭代。比如搜索或推荐系统的应用。</li>
</ul>
</blockquote>

<p>想象一下开发工程师需要和别人沟通原始需求的日子；自己整理需求、整理逻辑的日子；参与讨论产品视觉效果的日子。我不想说实话，不过必须承认工程师的沟通技巧和大多数人对产品的直觉都难以恭维。我想产品经理就是在这种情况下应运而生的职位吧。</p>

<p>如果我的假设没错的话，我认为产品经理的核心价值就体现在 3 点：</p>

<ol>
<li>善于倾听和整理，真正理解需求方的需求，设计出合理的使用流程</li>
<li>能够分辨纷杂需求中真正有价值的项目，能够控制产品的品质，而不是造一堆项目来回瞎折腾</li>
<li>更高级的是，对业务有着深刻理解和洞见，可以为公司创造一些产品，甚至成为新的流量/收入来源</li>
</ol>


<p>能做到上述所有 3 点的才能称为称职的产品经理，我想我也会很认同 TA 们的价值，实际上确实类似 manager，对自己的产品负责。</p>

<p>但问题在于，大多数产品经理其实很难达到上面的要求，很多大学生去做产品经理居然是因为不想写代码，只好去做产品，然后做个一年半载助理，开始自称「产品经理」，混迹于各个互联网公司，来回折腾没意义的项目。</p>

<p>写到这里，我心里已经有答案了。如果我来给各位产品总监的最重要的建议是：</p>

<ol>
<li>更明确产品这条职业道路上的几个阶段的标准，对「产品经理」这个词保持敬畏感，就好比开发人员对于计算机科学应该保持敬畏感。而不是「人人都是产品经理」。</li>
<li>将如何判断产品经理的好坏，以及如何能做出好产品尽可能的变成标准的方法论，这样对于人才培养和选拔都有好处，别人也更容易理解这个职业。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[换个姿势写博客]]></title>
    <link href="https://liangshan.blog/blog/2014/09/09/huan-ge-zi-shi-xie-bo-ke/"/>
    <updated>2014-09-09T15:39:18+08:00</updated>
    <id>https://liangshan.blog/blog/2014/09/09/huan-ge-zi-shi-xie-bo-ke</id>
    <content type="html"><![CDATA[<p>之前一直看 Hack News，最近开始看国内版本——Startup News。
结果里面看到王垠的那篇征集女粉丝的博文，后来他删了又写了篇撤回征集女粉丝，现在第二篇也已经删掉了。</p>

<p>以前读过别人分享他的一些文章，并没有读过他关于具体技术的见解。
这次系统了浏览一遍现在能看到的博文，之所以说现在能看到的，是因为他会删除文章，并且不许评论，应该是一个完美主义者吧（其实删除会导致一些文章中的链接失效，也不算十分完美）。
其中发现了一篇 <a href="http://www.yinwang.org/blog-cn/2014/04/24/sql-nosql/">SQL, NoSQL 以及数据库的实质</a>，读完之后的感觉是他看问题比我要深入很多。具体的细节我可能会单独写文章说明，不在这里展开。</p>

<p>所有文章都看完之后，我根本不想去评价王垠这个人，只想说他的文章给我带来什么思考。</p>

<p>能给人带来思考的文章都是好文章，他所写的每一篇都引起我思考。这只有一种可能就是他比我要厉害，主要是在思考问题的深度（无论对错）和在计算机科学学术方面。
学术和知识上比我厉害，这个其实很难追得起来（人家毕竟上了十年博士对吧，除去清华的 4 年，也还有 6 年 :P）。
但还好这个世界并不是谁学术能力强就一定取得更大成就。我稍微总结了一下，为什么他的文章能引发我思考。</p>

<p>首先是不信权威。完全不信权威难免有些绝对，我想更合理的理解这句话应该是，在选择相信权威之前先经过自己思考。只有当自己彻底想明白之后再接受别人的说法，而不是某句话听起来很酷，转身就变成自己的口头禅。直觉上大家都会认为自己不这样，但仔细想想这种例子其实太多。RTFSC 就是我中枪的一条，因为这是 Linus 大神说的。在这一点上我同意王垠的观点。别人期待的是你的经验之谈，而你甩出一句 「Read The F***ing Source Code」来伤害对方真的很酷？</p>

<p>其次是要努力看到本质。要看清技术的本质，需要很深的功力，这个也只能尽力而为了。但要时刻提醒自己，理解一个技术，需要从它要解决的问题根源开始思考，而不是看着手册学习手册。
比如我其实从来没有思考过「到底为什么要有 SQL」这种问题，我是说为什么是通过 SQL 这种方式来跟数据文件交互？因为习惯了 SQL，最开始用 MongoDB 之类的 NoSQL 的时候反而会不习惯，其实仔细想想 MongoDB 的交互终端才比较符合作为一个程序的用法。</p>

<p>从这一点上来说，这个博客虽然才写了几个月，但已经诞生了很多没有什么意义的文章。因为操作手册会过时，基本是没有意义的，但我应该不会删除它们。以这篇文章做分割线，看看以后会不会好一点。</p>

<p>我本来以为至少要几年后才会回头鄙视自己，没想到这个日子这么快就来了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在 Gentoo 上安装 Awesome]]></title>
    <link href="https://liangshan.blog/blog/2014/08/07/install-awesome-on-gentoo/"/>
    <updated>2014-08-07T14:06:30+08:00</updated>
    <id>https://liangshan.blog/blog/2014/08/07/install-awesome-on-gentoo</id>
    <content type="html"><![CDATA[<p>都装 gentoo 了，趁热装桌面环境吧。linux 的视窗系统称为 X Window System。
在开源世界里，通常是协议先行，各自实现。同样 X 只是协议，在各种实现中以 X.Org 最受欢迎，当时使用的协议为 X11，所以后来 X 也被人们称为 X11。</p>

<!-- more -->


<p>X 分为 server 和 client, 但这里的 server 和 client 和我直觉上的理解有点相反。比如接收用户行为的反而是 server。另外一大特色就是 client 之间是不知道对方存在的，比如桌面上运行了 terminal 和 chrome，它们之间的位置关系互相是不清楚的。所以需要一个软件来管理 client 的位置、大小、外观，同时提供类似于桌面的环境，这个软件就叫 X window manager，我们这里选择的是 awesome。X 具体的协议要去翻协议或者看 wiki 可以了解大概。</p>

<p>安装也分为 server 和 window manager 来进行。gentoo 安装每个软件基本上都会有一个 wiki 页面，照着手册来就可以了，所以建议照着 gentoo 的 wiki 来安装软件，而不是软件本身的手册。下面只讲手册上没说的内容，也就是我踩到的坑。</p>

<p>先讲 X server，第一次使用的驱动是开源版本 nouveau，也是手册上推荐的版本。但 awesome 装好之后无法启动。重新改了 make.conf 把显卡模块改为 nvidia 重装 server 就成功了。不知道是某款型号的个体问题还是普遍问题，仅供参考吧。</p>

<p>再说 awesome，首先要装较新版本的 awesome，这时候安装使用下面的命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ACCEPT_KEYWORDS="~*" emerge x11-wm/awesome</span></code></pre></td></tr></table></div></figure>


<p>装完之后运行 <code>startx</code> 应该有一个朴素的桌面启动了，这时候我们要花很多时间来美化它。</p>

<p>我是说在没有社区的情况下:D</p>

<p>github 上搜索 awesome themes，结果一大把了，早有人帮大家归纳了很多漂亮的皮肤，即使没有一个喜欢的，参考配置文件总是不错的。</p>

<p>我使用的叫做 <a href="https://github.com/copycat-killer/awesome-copycats">awesome-copycats</a>，除此之外还有中文字体，输入法，终端配置等等要折腾。我把用到的配置文件都放进 <a href="https://github.com/liangshan/liangshan.gentoo">github</a> 上，省的再次折腾。这里只是需要几个备注：</p>

<ol>
<li>这个皮肤的网络控件需要先安装 <code>iproute</code></li>
<li>编译终端需要 <code>USE=xft</code> 才能使用 X Font Server 的字体</li>
</ol>


<p>最后安装一下最新版的 firefox（仍然使用 <code>ACCEPT_KEYWORDS="~*"</code> 确保新版），需要提到的是 perl 的 <code>XML-Parser</code> 模块过期了，可能要先升级一下，否则编译过程会报错。</p>

<p>要注意整个过程都没有安装 DM(display manager)，还是手动的 <code>startx</code> 来启动，以后遇到问题再装吧。</p>

<p>上个图吧（为什么有种女人写美容攻略的感觉？），其实我最早就是想弄个 awesome，没想到整了这么多。</p>

<p><img src="https://liangshan.blog/images/custom/awesome.png" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 SystemRescueCD 安装 Gentoo]]></title>
    <link href="https://liangshan.blog/blog/2014/08/06/install-gentoo-from-systemrescuecd/"/>
    <updated>2014-08-06T17:50:10+08:00</updated>
    <id>https://liangshan.blog/blog/2014/08/06/install-gentoo-from-systemrescuecd</id>
    <content type="html"><![CDATA[<p>在使用 Ubuntu 有 3 年之后，第一次有了换个发行版的想法。
其实我觉得做任何事情都要循序渐进，在合适的时候做合适的事情才能事半功倍。</p>

<p>3 年前选择从 Ubuntu 入手应该是不错的选择，现在想换一个更自由的发行版也是水到渠成。选来选去，选了 gentoo，主要是在浏览的过程中以下几点吸引了我:</p>

<ol>
<li>自由度高，一切从头开始</li>
<li>升级频繁</li>
<li>很先进的包管理工具</li>
</ol>


<p>其实大多数时候我不是一个爱折腾的人，所以这次抓住了一闪而过想折腾的机会，第一天下午就开始动手了。第一个动作就是买一个 U 盘，是的，要准备一个 U 盘。</p>

<!-- more -->


<p>在开始之前，先说一下各个工具的版本。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SystemRescueCD == 4.3.0
</span><span class='line'>kernel == linux-3.14.14-gentoo
</span><span class='line'>gentoo == Gentoo Base System release 2.2</span></code></pre></td></tr></table></div></figure>


<p>原本我只是打算照着 gentoo 的手册从头看到尾，但第一章我就晕了，至少给了 3 种安装方式。选哪个好呢？经同事介绍：都不好。
有网络的条件下，最好是使用 SystemRescueCD 来安装。一开始我不太理解，装完之后我同意这种看法。</p>

<p>先讲 SystemRescueCD，这是一种特殊的 Live CD，内置了一个基于 Gentoo 内核的小型系统，以及一些很棒的工具。就像名字所指，主要用来恢复系统。
而这些「很棒的工具」就是 SystemRescueCD 来安装 gentoo 的最大优势。比如自带了 dhcp 客户端，很舒服的 bash 环境，elinks 在终端浏览网页等等。</p>

<p>简单来说，使用 SystemRescueCD 来安装 gentoo，可以直接跳到 gentoo 手册的第 4 章。而把 SystemRescueCD 装进 U 盘，只要参考 <a href="http://www.sysresccd.org/Sysresccd-manual-en_How_to_install_SystemRescueCD_on_an_USB-stick">wiki</a> 就可以了，分分钟就能搞定。</p>

<p>制作完成之后，插上 U 盘，从 U 盘启动，进入 systemrescd。然后我们跳到 <a href="https://www.gentoo.org/doc/en/handbook/handbook-amd64.xml?part=1&amp;chap=4">gentoo handbook 第 4 章</a>。第一，不要看中文版，已经不维护了，全部过时；第二，选好 CPU 架构，这篇是针对 amd64 或者叫 x86_64（这名字无力吐槽）。</p>

<p>gentoo 手册不只是告诉你步骤，还试图向你解释每一步的原因，当然可以选择略过。所以你也可以读完本文的一些解释，也可以略过:D</p>

<p>第 4 章的几个关键字：MBR， GPT， UEFI， BIOS boot partision。简单的把这些关键字串一下：上一代的计算机启动方式是 BIOS + MBR(Master Boot Record)，但两者有很多限制，也确实太过古老了。比如 MBR 使用 512 bytes 记录主分区信息，所以主分区数量受限制，虽然可以使用扩展分区和逻辑分区来弥补，但不够 native；以及 MBR 没有备份等问题。GPT 就是 MBR 的升级版，而 UEFI 就是针对 BIOS 的改进。而 BIOS boot 分区 主要是为了 GRUB2 准备的，也就是说如果使用 GRUB2 来选择操作系统，最好是有一个。需要特别说明的是，UEFI 需要主板支持，如果没有的话 BIOS + GPT 在大多数情况下可以的，除了要安装 windows（只认 UEFI + GPT 组合）。</p>

<p>给硬盘分好区并 mount 之后，就可以进入第 5 章。这里主要是准备整个安装过程会用到的一些工具，比如 stage3 安装包。名字很有趣，台阶。要知道除了 stage3 之外还有 stage2 和 stage1 可以选择。大概意思是你要从第几层开始工作，基本上越底层自己要做的工作就越多。新手就用 stage3 可以了，想要挑战的可以试试 stage2 和 stage1，这让我想起了 Diablo 3 的地狱和炼狱模式。这里需要注意的是，新的 SystemRescueCD 带的是 elinks，而不是手册上的 links，但用法基本是一样的。</p>

<p>第 6 章是装内核之前的准备，唯一要注意的是在选择 profile 的时候，因为是要装桌面环境，但我又不想用 GNOME 和 KDE，所以选择 desktop 选项就好了。</p>

<p>第 7 章安装内核，配置内核参数太过复杂，第一次安装基本就一路默认吧，或者直接使用 genkernel 让它自己来。这里 initramfs 最好装一下，虽然我还没有深入理解它的作用，但看介绍是需要的。</p>

<p>第 8 章开始装一些必要的软件了，这里唯一的问题是网卡的名字和默认的不一致。原因在<a href="http://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames/">这里</a>有详细解释，大概是说新版的 linux 设备管理器不再使用 <code>eth0</code> 这样的名字，而是给每个设备都按照固定规则分配一个固定的名字比如 <code>enp0s25</code>，所以网络配置需要拿到真实的名字之后重新配一下。</p>

<p>除了手册上的软件之外，我这里再补充 2 个。<code>sudo</code> 居然也没有，这个挺让我惊讶的，另外一个就是 <code>git</code>。</p>

<p>然后一路到底就可以啦，整个过程最需要的条件是内存和网络。而我选择了跳过最复杂的 USE 配置及内核参数配置，所以还算顺利。</p>

<p>如果重启后无法进入系统，恭喜你获得了再来一次的机会。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[七年之痒]]></title>
    <link href="https://liangshan.blog/blog/2014/07/02/seven-year-itch/"/>
    <updated>2014-07-02T15:34:35+08:00</updated>
    <id>https://liangshan.blog/blog/2014/07/02/seven-year-itch</id>
    <content type="html"><![CDATA[<blockquote><p>“七年之痒”是个舶来词，人的细胞七年会完成一次整体的新陈代谢，可能七年后你就不爱这个人了。</p></blockquote>

<p>我跟老婆不知不觉认识已经有七年了。</p>

<p>但今天说的跟老婆没什么关系。</p>

<p>因为再往前就是工作的第七个年头。</p>

<!-- more -->


<p>想到写这个话题是因为最近看 2 个不相关的开源软件，发现最终都指向了 TCP/IP 协议的相关细节。
最近一年总是有这种感觉，软件的背后总是指向「那几样东西」。</p>

<p>魂牵梦绕，挥之不去。</p>

<p>人总是会觉得以前的想法很傻。所以冒着被以后的自己鄙视的风险，说说现在我对技术的理解。</p>

<p>其实我并不是狂热的技术追求者，那种废寝忘食，涉猎技术的方方面面的人。我很钦佩那种人，但我清楚的知道我不是。
有时候知道自己不是什么，比知道是什么更可贵。因为这让我更具有专注力，知道怎么能够事半功倍。</p>

<p>在我看来，技术总是为了实现人类需求而发展。某些革命性技术的出现又会推动人类发展从而产生更多的需求。
但对于大多工程师来讲，基本上以满足需求为主要的工作内容。
在自由软件和开源软件运动的驱动下，我们非常便利的获取别人的软件和成果。
配合标准化的软件开发流程管理，好像开发软件变成了非常容易的事情，软件工程师甚至被称为「码农」。
但随着对技术了解的越多，越发现「根基」的重要性。</p>

<blockquote><p>&ldquo;Good developers know how things work. Great developers know why things work.&rdquo;</p></blockquote>

<p>我大概要给它加上一句 &ldquo; developers know how to work with things. &rdquo;</p>

<p>技术的知识图谱如果画出来，应该是一个枝繁叶茂的大树。
大树的每片叶子是一个个软件，大树的根基是我前面提到的「那几样东西」。
从每片叶子深入探索，你在最后总是碰到它们。</p>

<p>其实就是大学里面学到的那些基础课程：数据结构、编译原理、计算机网络、操作系统。</p>

<p>上大学的时候觉得这些课程很无聊，但最近却常常后悔没有把这些知识学好，或者常常有那种感觉「哦！学校里学的XX原来是这个意思」。
学校教理论没错，工作中实践也没错。我觉得问题可能出在学校里没有把理论和实践结合起来，这是题外话就此打住。</p>

<p>只有掌握了这些根基，才能更快的了解新技术、新软件，才能更好的使用他们，甚至是站在设计者的角度理解他们。
只有掌握了这些根基，才能在设计时像搭积木一样设计出优雅的系统。</p>

<p>说到搭积木，影响我最深的应该是 UNIX 的设计哲学：只做一件事，做好它。
一个复杂的系统应该是由多个简单的系统搭建而成，每个系统都应该有自己标准输入输出。再复杂的系统，看每个组件都应该是足够小而优雅。
这让我想起了上学的时光。上学的时候我总结出一条规律：任何难题都是经过很多小题组合嵌套而成，嵌套的层数越多就越难。</p>

<p>好像我从小就展露了工程师潜力呢:D</p>

<p>最后送上一些感悟吧：</p>

<p>面对这棵大树，必须保持一定的敬畏感，因为你知道它太大了，甚至无法看清它的全貌。</p>

<p>面对这棵大树，必须保持一定的自信，因为它每一个小的枝叶都足以给你丰富的养料。</p>

<p>面对这棵大树，必须保持一定的开放心态，因为它每一个枝叶都有不同的精彩，不要一叶障目。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Build a Scalable Recommendation System]]></title>
    <link href="https://liangshan.blog/blog/2014/06/08/build-a-scalable-recommendation-system/"/>
    <updated>2014-06-08T20:06:19+08:00</updated>
    <id>https://liangshan.blog/blog/2014/06/08/build-a-scalable-recommendation-system</id>
    <content type="html"><![CDATA[<p>从接触推荐系统以来，断断续续的已经有一年半的时间了。
今天想单纯从工程角度来总结一下我得到的经验，不涉及推荐的数学算法和理论。
第一是公司还没有到必须扩展现有的推荐算法的地步，第二是本人自知没有足够能力来改进现有的推荐算法。</p>

<p>其实主要是因为第二点。</p>

<h2>总体回顾</h2>

<p>在介绍可扩展的推荐平台我是如何设计之前，还是稍微回顾一下公司推荐的发展历程，因为这可能具有一定的代表性。或许在开展新的推荐研究时有一定参考价值。</p>

<h3>诺基亚</h3>

<p>我开始做推荐之前一直是我们数据部门的同学来做的，当时是使用 SQL 查询来实现了推荐的相关算法。想必这也是不得已而为之吧，最起码说明算法理论很熟悉:P。
调整一些参数或是新增推荐显然很痛苦。</p>

<p>但有总比没有强，在 iPhone 出现之前，诺基亚一直已智能手机自居。人们的感觉是跟智能有点关系，但总觉得怪怪的。这也是当时我们公司使用推荐的感觉。</p>

<h3>Romar</h3>

<p>在开始做新的推荐引擎之后，我们的思路就是找一个开源实现。很快就锁定了 <a href="https://mahout.apache.org/">Mahout</a>，原因有以下几点:</p>

<ol>
<li>Apache 基金，项目的更新和质量有保证</li>
<li>实现了大多数已知的推荐算法，同时考虑了机器学习的其他两个分支：聚类和分类</li>
<li>分布式计算，为大数据而设计</li>
</ol>


<p>但 Mahout 只是一个类库，我一直喜欢拿 Solr 和 Lucence 的关系来类比。 Mahout 类似 Lucence 是一个底层类库，并不是上层应用和产品。
于此同时，Mahout 版本的 &lsquo;Solr&rsquo; 还没有出现，有几款开源实现但并不理想，也不是 Apache 官方的作品。</p>

<p>所以我们决定自己简单的在 Mahout 上面薄薄的搭一层 API 来提供服务，起了个名字叫 Romar。很快这个目的就实现了，项目可以在 <a href="https://github.com/anjuke/romar">GitHub</a> 上找到。</p>

<p>Romar 1.0 的版本应该足以应付千万级别用户行为的协同过滤计算，所以很快在公司内部得到了快速应用。
得益于其能够快速响应业务需求的特点，短短半年内覆盖了公司所有产品线，这也算技术推动产品的经典案例了。</p>

<p>但问题随之而来。</p>

<p>管理这些推荐引擎变得痛苦，越来越多的实例。它们的管理成了最大的问题，包括部署、监控、可靠性、平滑升级。</p>

<!-- More -->


<h2>备选方案</h2>

<p>很显然需要一个平台来管理这些实例，同时推荐引擎本身也需要一些升级。</p>

<ol>
<li>平台来管理、部署实例及其配置</li>
<li>平台来查看实例服务的状态</li>
<li>推荐引擎为以后准备，支持海量数据的离线计算</li>
</ol>


<p>与刚开始时类似，我们也找了几个开源实现，其实和我们思路类似，都是基于 Mahout 的一些产品，这里稍作介绍。</p>

<h3>PredictionIO vs Oryx</h3>

<p><a href="http://prediction.io/">PredictionIO</a> 是一个大而全的产品。说到「大而全」，已经概括了我对这个产品的看法。</p>

<ol>
<li>主打 Cloud 业务，即部署在他们的云端。这是主要的盈利方式。只是顺便开源了代码，可以自己搭建。</li>
<li>但自己搭建并没有很好的脚手架或是文档，开源的安装脚本落后且复杂，一旦出错需要从头开始。</li>
<li>配置太多，把更多的选择留给用户，看似是自由度很高，反过来看就是复杂。</li>
<li>唯一可取的是界面样式设计很有科技感。</li>
</ol>


<p>所以 PredictionIO 还没到真实数据测试阶段就已经被放弃了。</p>

<p><a href="https://github.com/cloudera/oryx">Oryx</a> 的前身叫 Myrrix，后来被 Cloudera 收购改了这个名字。值得一提的是 Oryx 的维护者就是 Mahout 的主要贡献者。</p>

<p>严格来讲 Oryx 并不是我要找的「平台」，但我们考虑用来直接代替 Romar 来作为后端引擎。</p>

<p>Oryx 具有以下特点：</p>

<ol>
<li>Hadoop 版本跟着 CDH 升级</li>
<li>将推荐引擎分为 Serving Layer 和 Computing Layer，隔离出 Serving Layer 让扩展变得很容易</li>
<li>同时支持推荐、聚类、分类的机器学习</li>
<li>数据引入了 Generation 的概念，提供了很好的增量补充数据的支持</li>
</ol>


<p>看起来很美好，试用之后发现了一些问题，其中的大多数都与作者做了深入的沟通，总结起来可能有以下几点:</p>

<ol>
<li>没有额外的组件，意味着没有额外的存储空间。Serving Layer 内存有瓶颈。</li>
<li>只支持了一种协同过滤算法，即 <a href="https://github.com/cloudera/oryx#collaborative-filtering--recommendation">ALS (alternating least squares) </a>。这种算法精度更高，但计算时间长，且中间结果无法缓存，Serving Layer 在不到百兆数据级别就会响应很慢。
具体可以看这个 <a href="https://github.com/cloudera/oryx/issues/55">issue</a>。</li>
</ol>


<p>基于以上 2 点，我们还是最终没有把 Oryx 应用到生产中。</p>

<h2>The answer</h2>

<p>我们总是讨厌重复造轮子，但如果能基于现有方案造出更好的轮子，也不失为一种选择。</p>

<p>融合了 PredictionIO 与 Oryx 的优点，我认为一个用户友好的、可扩展的、成熟的推荐系统应该具备以下特点:</p>

<ol>
<li>方便部署。应该使用一些 CM(Configure Management) 工具，或者配合 Docker、Vagrant 等虚拟环境来快速的搭建统一的环境。</li>
<li>支持多种算法，有些场景简单的余弦相似度已经满足需求。</li>
<li>Serving Layer 要与 Computing Layer 解耦。</li>
<li>增加 key-value 缓存层，释放 Serving Layer 的内存压力。</li>
<li>平台界面操作简单，尽可能的对用户隐藏后端引擎的细节。</li>
<li>推荐引擎对客户端透明，这个比较难理解，后面单独说明。</li>
</ol>


<p>设想中的架构应该类似于这样:</p>

<p><img src="https://liangshan.blog/images/custom/rec-arch.png" /></p>

<h3>Platform</h3>

<p>从平台的逻辑角度来说，可以将推荐引擎分为两层: App 和 Instance。</p>

<p>一个 App 字面上理解就是一个推荐应用，应该包括了使用的数据和引擎的配置。
一个 App 可以有多个 Instance 同时进行服务，各个 Instance 使用 App 的数据和配置。</p>

<p>创建新的推荐应用<strong>不需要</strong>关心背后使用的引擎、版本，以及部署在哪台机器、哪个端口（但在创建完成后可以查看）。</p>

<h3>Serving Layer</h3>

<p>仅从 Cache 中获取结果返回给客户端。同时保留将来一定的扩展性，比如没有读到数据可以发指令给 Computing Layer 重新计算。</p>

<h3>Computing Layer</h3>

<p>同时支持离线集群计算和单机计算。当单机计算时，计算结果直接存入 Cache；当离线计算时，将结果从集群中读出后转存至 Cache。</p>

<h3>Data Storage</h3>

<p>如何获取和存储用户行为是另外一个很大的课题，不在这里展开。这里我们假设可以方便的拿到所有用户行为。</p>

<h3>CRGI</h3>

<p>受到 <a href="http://en.wikipedia.org/wiki/Common_Gateway_Interface">CGI(Common Gateway Interface)</a> 的启发，我认为只要规定好输入输出，推荐的客户端可以无视后端引擎。
而后端引擎可以只要满足输入输出，便可以随意更换实现。</p>

<p>即 CRGI(Common Recommendation Gateway Interface)，CRGI 是一份协议或声明，凡是满足协议中描述的输入输出，理论上都可以作为这套系统的推荐引擎。</p>

<p>由于这里 Serving Layer 由我们自己控制，所以一定是满足 CRGI 协议。如果后端更换了第三方引擎，则需要 Proxy 来适配。</p>

<h3>Load Balance</h3>

<p>在所有 Serving Layer 的 HTTP Server 之前加一层 LB。
这样可以进一步简化客户端调用，不需要知道 IP 地址和端口号。同时可以在 LB 上统一的管理所有 APP 的访问日志。</p>

<h3>Logs and Monitor</h3>

<p>访问日志由 LB 统一管理，Error Log 则由各 App 自己管理。可以使用第三方工具来监控 Error Log 并依据访问日志来绘图。
最终展示在 Platform 上。</p>

<h3>Engine Upgrade</h3>

<ol>
<li>所有 App 使用同一版本引擎</li>
<li>如果更换引擎则所有 App 需要同时更换</li>
<li>如果引擎升级，则视为一次更换</li>
</ol>


<p>避免了 App 间的版本差异，会给管理带来很多好处。只是需要制定详尽的在线升级策略。</p>

<p>做到了以上几点应该可以构建出非常强大而灵活的推荐系统。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何将 Octopress 的文章分享至微信和微博]]></title>
    <link href="https://liangshan.blog/blog/2014/05/28/how-to-share-octopress-pages-to-weixin-and-weibo/"/>
    <updated>2014-05-28T12:54:14+08:00</updated>
    <id>https://liangshan.blog/blog/2014/05/28/how-to-share-octopress-pages-to-weixin-and-weibo</id>
    <content type="html"><![CDATA[<p>昨天想把自己的文章分享到微信，没有仔细思考选了一种很土的办法。就是直接在微信的内容里输入地址，容易出错不说，效率也很低下。
今天再回头思考这个问题，想到可以像 twitter 和 google+ 一样做一个分享按钮。Octopress 自己是不带国内社交网站分享的，要稍微做点功课。</p>

<!-- more -->


<p>稍微想了一下，发现微信较为特殊，因为只有手机应用，想要把网页分享至 app，只能曲线救国，想办法把网址输入到手机，然后使用 app 的功能再分享。</p>

<p>后来搜索了一下，发现 <a href="http://www.jiathis.com">jiathis.com</a> 已经按照这个思路做过了。自不必说是「模仿」 <a href="http://www.addthis.com">addthis.com</a>，连域名都如此相似:P。</p>

<h2>注册</h2>

<p>需要先注册一个 jiathis 用户，注册过程很简洁，好像也没有验证邮箱。注册完就直接跳转到加码页，也算是体验不错。</p>

<h2>修改 Octopress</h2>

<p>接下来需要做 4 项源代码级别的修改。修改的流程遵循 Octopress 自己的逻辑，比葫芦画瓢的改法，而不是直接贴代码了事。</p>

<h3>添加 config</h3>

<p>在 <code>__config.yml</code> 中添加 jiathis 的相关配置，<code>$uid</code> 替换为真正的 <code>userid</code>，<code>userid</code> 可以从 jiathis 的示例代码中获取。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="c1">## __config.yml</span>
</span><span class='line'><span class="c1">## 下面的内容添加至文件尾部</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Jiathis</span>
</span><span class='line'><span class="l-Scalar-Plain">jiathis_user</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">$uid</span>
</span><span class='line'><span class="l-Scalar-Plain">jiathis_share</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true</span>
</span></code></pre></td></tr></table></div></figure>


<h3>修改模板文件</h3>

<p>下面的代码首先是拆成几部分，上面讲过要符合 octopress 的做法，另外我精简过了。
jiathis 给的代码带一个「+」号还有分享数字，样式很不河蟹被我删掉了。
另外 jiathis 还会默认开启 site tracker 功能，我觉得这个有点多余，这部分代码我也都删掉了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='html+jinja'><span class='line'>  # source/_include/post/sharing
</span><span class='line'>  <span class="c">&lt;!-- 添加到相应的位置，twitter google+ 前后皆可 --&gt;</span>
</span><span class='line'>  <span class="cp">{%</span> <span class="k">if</span> <span class="nv">site.jiathis_share</span> <span class="cp">%}</span>
</span><span class='line'>  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;jiathis_style_24x24&quot;</span> <span class="na">style=</span><span class="s">&quot;text-indent: 0px; margin: 0px; padding: 0px; border-style: none; float: none; line-height: normal; font-size: 1px; vertical-align: baseline; display: inline-block;  background: transparent;&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;a</span> <span class="na">class=</span><span class="s">&quot;jiathis_button_weixin&quot;</span><span class="nt">&gt;&lt;/a&gt;</span>
</span><span class='line'>    <span class="nt">&lt;a</span> <span class="na">class=</span><span class="s">&quot;jiathis_button_tsina&quot;</span><span class="nt">&gt;&lt;/a&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/div&gt;</span>
</span><span class='line'>  <span class="cp">{%</span> <span class="k">endif</span> <span class="cp">%}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='html+jinja'><span class='line'># source/_includes/after_footer.html
</span><span class='line'><span class="c">&lt;!-- 只加第 5 行 --&gt;</span>
</span><span class='line'><span class="cp">{%</span> <span class="k">include</span> <span class="nv">disqus.html</span> <span class="cp">%}</span>
</span><span class='line'><span class="cp">{%</span> <span class="k">include</span> <span class="nv">facebook_like.html</span> <span class="cp">%}</span>
</span><span class='line'><span class="cp">{%</span> <span class="k">include</span> <span class="nv">google_plus_one.html</span> <span class="cp">%}</span>
</span><span class='line'><span class="cp">{%</span> <span class="k">include</span> <span class="nv">twitter_sharing.html</span> <span class="cp">%}</span>
</span><span class='line'><span class="cp">{%</span> <span class="k">include</span> <span class="nv">jiathis_share.html</span> <span class="cp">%}</span>
</span><span class='line'><span class="cp">{%</span> <span class="k">include</span> <span class="nv">custom</span><span class="o">/</span><span class="nv">after_footer.html</span> <span class="cp">%}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='html+jinja'><span class='line'># 添加一个文件
</span><span class='line'>$ touch source/_includes/jiathis_share.html
</span><span class='line'>$ vi source/_includes/jiathis_share.html
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='html+jinja'><span class='line'># 该文件的内容
</span><span class='line'>
</span><span class='line'><span class="cp">{%</span> <span class="k">if</span> <span class="nv">site.jiathis_share</span> <span class="cp">%}</span>
</span><span class='line'><span class="nt">&lt;div</span> <span class="na">style=</span><span class="s">&quot;display:none&quot;</span><span class="nt">&gt;</span>
</span><span class='line'><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span> <span class="na">src=</span><span class="s">&quot;http://v3.jiathis.com/code/jia.js?uid=</span><span class="cp">{{</span> <span class="nv">site.jiathis_user</span> <span class="cp">}}</span><span class="s">&quot;</span> <span class="na">charset=</span><span class="s">&quot;utf-8&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</span><span class='line'><span class="nt">&lt;/div&gt;</span>
</span><span class='line'><span class="cp">{%</span> <span class="k">endif</span> <span class="cp">%}</span>
</span></code></pre></td></tr></table></div></figure>


<p>之后就可以在本地预览并部署了。</p>
]]></content>
  </entry>
  
</feed>
