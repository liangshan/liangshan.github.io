<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Liangshan's Blog]]></title>
  <link href="http://liangshan.me/atom.xml" rel="self"/>
  <link href="http://liangshan.me/"/>
  <updated>2014-05-28T14:14:57+08:00</updated>
  <id>http://liangshan.me/</id>
  <author>
    <name><![CDATA[Liangshan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何将 Octopress 的文章分享至微信和微博]]></title>
    <link href="http://liangshan.me/blog/2014/05/28/how-to-share-octopress-pages-to-weixin-and-weibo/"/>
    <updated>2014-05-28T12:54:14+08:00</updated>
    <id>http://liangshan.me/blog/2014/05/28/how-to-share-octopress-pages-to-weixin-and-weibo</id>
    <content type="html"><![CDATA[<p>昨天想把自己的文章分享到微信，没有仔细思考选了一种很土的办法。就是直接在微信的内容里输入地址，容易出错不说，效率也很低下。
今天再回头思考这个问题，想到可以像 twitter 和 google+ 一样做一个分享按钮。Octopress 自己是不带国内社交网站分享的，要稍微做点功课。</p>

<!-- more -->


<p>稍微想了一下，发现微信较为特殊，因为只有手机应用，想要把网页分享至 app，只能曲线救国，想办法把网址输入到手机，然后使用 app 的功能再分享。</p>

<p>后来搜索了一下，发现 <a href="http://www.jiathis.com">jiathis.com</a> 已经按照这个思路做过了。自不必说是「模仿」 <a href="http://www.addthis.com">addthis.com</a>，连域名都如此相似:P。</p>

<h2>注册</h2>

<p>需要先注册一个 jiathis 用户，注册过程很简洁，好像也没有验证邮箱。注册完就直接跳转到加码页，也算是体验不错。</p>

<h2>修改 Octopress</h2>

<p>接下来需要做 4 项源代码级别的修改。修改的流程遵循 Octopress 自己的逻辑，比葫芦画瓢的改法，而不是直接贴代码了事。</p>

<h3>添加 config</h3>

<p>在 <code>__config.yml</code> 中添加 jiathis 的相关配置，<code>$uid</code> 替换为真正的 <code>userid</code>，<code>userid</code> 可以从 jiathis 的示例代码中获取。</p>

<figure class='code'><figcaption><span>__config.yml</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="c1">## 下面的内容添加至文件尾部</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Jiathis</span>
</span><span class='line'><span class="l-Scalar-Plain">jiathis_user</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">$uid</span>
</span><span class='line'><span class="l-Scalar-Plain">jiathis_share</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true</span>
</span></code></pre></td></tr></table></div></figure>


<h3>修改模板文件</h3>

<p>下面的代码首先是拆成几部分，上面讲过要符合 octopress 的做法，另外我精简过了。
jiathis 给的代码带一个「+」号还有分享数字，样式很不河蟹被我删掉了。
另外 jiathis 还会默认开启 site tracker 功能，我觉得这个有点多余，这部分代码我也都删掉了。</p>

<figure class='code'><figcaption><span>source/_include/post/sharing</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='html+jinja'><span class='line'>  <span class="c">&lt;!-- 添加到相应的位置，twitter google+ 前后皆可 --&gt;</span>
</span><span class='line'>  <span class="cp">{%</span> <span class="k">if</span> <span class="nv">site.jiathis_share</span> <span class="cp">%}</span>
</span><span class='line'>  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;jiathis_style_24x24&quot;</span> <span class="na">style=</span><span class="s">&quot;text-indent: 0px; margin: 0px; padding: 0px; border-style: none; float: none; line-height: normal; font-size: 1px; vertical-align: baseline; display: inline-block;  background: transparent;&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;a</span> <span class="na">class=</span><span class="s">&quot;jiathis_button_weixin&quot;</span><span class="nt">&gt;&lt;/a&gt;</span>
</span><span class='line'>    <span class="nt">&lt;a</span> <span class="na">class=</span><span class="s">&quot;jiathis_button_tsina&quot;</span><span class="nt">&gt;&lt;/a&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/div&gt;</span>
</span><span class='line'>  <span class="cp">{%</span> <span class="k">endif</span> <span class="cp">%}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>source/_includes/after_footer.html</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='html+jinja'><span class='line'><span class="c">&lt;!-- 只加第 5 行 --&gt;</span>
</span><span class='line'><span class="cp">{%</span> <span class="k">include</span> <span class="nv">disqus.html</span> <span class="cp">%}</span>
</span><span class='line'><span class="cp">{%</span> <span class="k">include</span> <span class="nv">facebook_like.html</span> <span class="cp">%}</span>
</span><span class='line'><span class="cp">{%</span> <span class="k">include</span> <span class="nv">google_plus_one.html</span> <span class="cp">%}</span>
</span><span class='line'><span class="cp">{%</span> <span class="k">include</span> <span class="nv">twitter_sharing.html</span> <span class="cp">%}</span>
</span><span class='line'><span class="cp">{%</span> <span class="k">include</span> <span class="nv">jiathis_share.html</span> <span class="cp">%}</span>
</span><span class='line'><span class="cp">{%</span> <span class="k">include</span> <span class="nv">custom</span><span class="o">/</span><span class="nv">after_footer.html</span> <span class="cp">%}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>添加一个文件</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>touch <span class="nb">source</span>/_includes/jiathis_share.html
</span><span class='line'><span class="nv">$ </span>vi <span class="nb">source</span>/_includes/jiathis_share.html
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>该文件的内容</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='html+jinja'><span class='line'><span class="cp">{%</span> <span class="k">if</span> <span class="nv">site.jiathis_share</span> <span class="cp">%}</span>
</span><span class='line'><span class="nt">&lt;div</span> <span class="na">style=</span><span class="s">&quot;display:none&quot;</span><span class="nt">&gt;</span>
</span><span class='line'><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span> <span class="na">src=</span><span class="s">&quot;http://v3.jiathis.com/code/jia.js?uid=</span><span class="cp">{{</span> <span class="nv">site.jiathis_user</span> <span class="cp">}}</span><span class="s">&quot;</span> <span class="na">charset=</span><span class="s">&quot;utf-8&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</span><span class='line'><span class="nt">&lt;/div&gt;</span>
</span><span class='line'><span class="cp">{%</span> <span class="k">endif</span> <span class="cp">%}</span>
</span></code></pre></td></tr></table></div></figure>


<p>之后就可以在本地预览并部署了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我为什么如此反感在公司放广播]]></title>
    <link href="http://liangshan.me/blog/2014/05/27/why-i-hate-broadcasting-at-company/"/>
    <updated>2014-05-27T17:27:33+08:00</updated>
    <id>http://liangshan.me/blog/2014/05/27/why-i-hate-broadcasting-at-company</id>
    <content type="html"><![CDATA[<p>最近公司决定在早中晚全公司范围内播放广播。早晚内容是「广告」和「司歌」，中午是罗振宇的「罗辑思维」片段。</p>

<p>对此我在微信上表达了强烈的愤怒，措辞很激进。坦白来讲，我倒是希望有人传话给决策者，让他们知道我的愤怒，不是我不想混了，因为我相信我有足够的理由和众多的支持者，只是大家都不敢出声罢了。</p>

<!-- more -->


<p>其实我的理由很简单：</p>

<ol>
<li>作为一个 TIAN CHAO 屁民，难道受强迫还少么？大家应该对强制性措施有一种「天然的抵触」</li>
<li>作为一个工程师，更不应该容忍一切封闭的、无法控制、强制性的事情。</li>
<li>甚至我觉得可以上升到人权角度。</li>
</ol>


<p>在 <a href="http://translations.readthedocs.org/en/latest/hacker_howto.html#id9">How to be a hacker</a> 中有详细的描述了黑客应具备的几种态度，其中一条是「崇尚自由」:</p>

<blockquote><p>黑客们是天生的反权威主义者。任何能向你发号施令的人都可以让你停止解决令你着迷的问题，同时，按照权威主义者的一般思路，他通常会给出一些极端愚昧的理由。因此，不论何处，任何权威主义的做法，只要它影响到了你和其他的黑客，你就要和它斗到底。</p>

<p>（这并非向所有权威挑战。儿童需要监护，罪犯要被看管起来。如果服从命令得到某种东西比起用其他方式得到它更节约时间，黑客可以同意接受某种形式的权威。但这是一个有限度的，斟酌过的的交易；那种权威主义者想要的个人服从是不在考虑范围内的。）</p>

<p>权威主义者喜欢审查和保密。他们不信任自愿的合作和信息的共享——他们只喜欢由他们控制的所谓“合作”。因此，作为一个黑客，你应该对审查、保密，以及使用武力或欺骗去压迫有行为能力的人们的做法有一种本能的敌意。同时你要有为此信念付出的意愿。</p></blockquote>

<p>我既然提出了问题，自然会奉上解决方案。</p>

<p>一样作为互联网公司，看看别人的做法: <a href="https://github.com/play/play">GitHub/Play</a>，我并没有贬低任何人的意思，不过有双眼睛就能分辨哪种方案更好。是强制性播放，还是随意性收听。</p>

<blockquote><p>Play is an employee-powered iTunes-based client-driven distributed music server for your office. Also it can prepare your taxes.</p>

<p><img src="https://camo.githubusercontent.com/7eae837ee32161f7a22ba0f064f0e976f10ea2de/687474703a2f2f636c2e6c792f316c336f3070304b334f3172304332553361335a2f706c61792e706e67" alt="" /></p></blockquote>

<p>这事说大不大，不过真的非常令人沮丧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Isolate Ansible Code and Source Code]]></title>
    <link href="http://liangshan.me/blog/2014/05/22/isolate-ansible-code-and-source-code/"/>
    <updated>2014-05-22T16:56:16+08:00</updated>
    <id>http://liangshan.me/blog/2014/05/22/isolate-ansible-code-and-source-code</id>
    <content type="html"><![CDATA[<p>我们经常要开发一些「系统」，这些「系统」具备以下特点：</p>

<ul>
<li>用到很多系统软件。比如 ngnix, compass, ruby, mongodb 等等；</li>
<li>项目本身有很多组件组成。比如 web 程序，job 系统和对应的消息队列；</li>
</ul>


<p>那么在开发这类系统时就会遇到一些问题：</p>

<ul>
<li>开发环境和线上环境不等价。平台可能不同，软件版本可能不同；</li>
<li>开发环境配置复杂，任意环节出错就会影响整个系统的启动；</li>
</ul>


<p>为了解决这些问题，我们将整个环境安装在虚拟机内，这在安居客被认为是一种最佳实践，成功的应用在很多系统的开发当中。
而开发环境，生产环境的部署则交给 ansible 来完成。那么我们的项目目录看起来是这样:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> .                  # root  
</span><span class='line'> |-- .provisioning/ # ansible 脚本目录
</span><span class='line'> |-- src/           # 源代码目录
</span><span class='line'> |-- Vagrantfile    # vagrant 启动脚本</span></code></pre></td></tr></table></div></figure>


<p>这样有一个好处，虚拟机启动之后，源代码对应 <code>/vagrant</code> 这个共享目录，修改源代码会同时在虚拟机内生效。
但这样 ansible 或是其他一些 CM(Configure Management) 工具的代码和源代码就会混在一个仓库内。</p>

<p>本文就介绍一种简单的方法可以将 DevOps 的代码与源代码隔离，并达到相同的效果。</p>

<!-- more -->


<p>首先我们需要准备两个仓库，一个源代码仓库我们暂且叫做 <code>src</code>，另一个仓库 <code>src-ansible</code> 放 ansible 脚本。</p>

<h2>src-ansible</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> .
</span><span class='line'> |-- host_vars/
</span><span class='line'> |-- roles/
</span><span class='line'> |-- playbook.xml
</span><span class='line'> |-- host.vagrant
</span><span class='line'> |-- .Vagrantfile</span></code></pre></td></tr></table></div></figure>


<p>其他都是常规的 ansible 脚本，唯独 <code>.Vagrantfile</code> 比较特殊。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># -*- mode: ruby -*-</span>
</span><span class='line'><span class="c1"># vi: set ft=ruby :</span>
</span><span class='line'>
</span><span class='line'><span class="no">Vagrant</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="s2">&quot;2&quot;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
</span><span class='line'>  <span class="n">config</span><span class="o">.</span><span class="n">vm</span><span class="o">.</span><span class="n">box</span> <span class="o">=</span> <span class="s2">&quot;trusty32&quot;</span>
</span><span class='line'>  <span class="n">config</span><span class="o">.</span><span class="n">vm</span><span class="o">.</span><span class="n">box_url</span> <span class="o">=</span> <span class="s2">&quot;http://vagrant.corp.anjuke.com/boxes/trusty32.box&quot;</span>
</span><span class='line'>  <span class="n">config</span><span class="o">.</span><span class="n">vm</span><span class="o">.</span><span class="n">network</span> <span class="ss">:private_network</span><span class="p">,</span> <span class="ss">ip</span><span class="p">:</span> <span class="s2">&quot;192.168.222.22&quot;</span>
</span><span class='line'>  <span class="c1"># config.vm.network &quot;public_network&quot;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">config</span><span class="o">.</span><span class="n">vm</span><span class="o">.</span><span class="n">provision</span> <span class="ss">:ansible</span> <span class="k">do</span> <span class="o">|</span><span class="n">ansible</span><span class="o">|</span>
</span><span class='line'>    <span class="n">ansible</span><span class="o">.</span><span class="n">playbook</span> <span class="o">=</span> <span class="s1">&#39;.provisioning/playbook.yml&#39;</span>
</span><span class='line'>    <span class="n">ansible</span><span class="o">.</span><span class="n">inventory_path</span> <span class="o">=</span> <span class="s1">&#39;.provisioning/hosts.vagrant&#39;</span>
</span><span class='line'>    <span class="n">ansible</span><span class="o">.</span><span class="n">host_key_checking</span> <span class="o">=</span> <span class="kp">false</span>
</span><span class='line'>    <span class="n">ansible</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="s1">&#39;vvvv&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>你会发现这里面用到的 <code>playbook</code> 和 <code>inventory</code> 路径都不存在，文件名也以 <code>.</code> 开头。其实这个文件就是给源代码仓库用的，而不能在这里直接使用。</p>

<p>这里借鉴了 Ruby On Rails 的一个重要思想「约定大于配置」。比如这里约定了源代码仓库的 ansible 脚本放在 <code>.provisioning</code> 这个目录。</p>

<h2>src</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'> .
</span><span class='line'> |-- src/
</span><span class='line'> |-- Makefile
</span><span class='line'> |-- .gitignore
</span></code></pre></td></tr></table></div></figure>


<p><code>.gitgnore</code> 添加以下内容：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>.vagrant/
</span><span class='line'>.provisioning/
</span><span class='line'>Vagrantfile
</span></code></pre></td></tr></table></div></figure>


<p><code>make</code> 其实就是执行一些 shell 命令，如果翻译成 shell 应该类似下面的脚本。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>mkdir .provisioning
</span><span class='line'><span class="nb">cd</span> .provisioning
</span><span class='line'>git init
</span><span class='line'>git remote add origin git@gitserver.com:username/src-ansible.git
</span><span class='line'>git pull origin master
</span><span class='line'>cp .Vagrantfile ../Vagrantfile
</span></code></pre></td></tr></table></div></figure>


<p>于此对应，再写一个 <code>make</code> 的 <code>target</code> 用于更新 ansible 脚本。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">cd</span> .provisioning
</span><span class='line'>git pull origin master
</span><span class='line'>cp .Vagrantfile ../Vagrantfile
</span></code></pre></td></tr></table></div></figure>


<p>完成了这些步骤，就可以直接在源代码仓库使用 vagrant 的命令来安装、更新虚拟机。但又可以将这些脚本与源代码隔离开来。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Twelve-Factor App]]></title>
    <link href="http://liangshan.me/blog/2014/05/22/the-twelve-factor-app/"/>
    <updated>2014-05-22T16:37:03+08:00</updated>
    <id>http://liangshan.me/blog/2014/05/22/the-twelve-factor-app</id>
    <content type="html"><![CDATA[<p>前些年翻译的 <a href="http://12factor.net/">12-factor</a>。一直放在公司内部的博客上，现在复制一份过来。</p>

<hr />

<p><img class="right" src="http://0.gravatar.com/avatar/7cdf5b1c46308979e3bf81390b0c8639"></p>

<p>中文翻译：<a href="https://github.com/liangshan/">梁山</a><br/>
英文原文：<a href="http://www.12factor.net/">Adam Wiggins</a></p>

<p><em><a href="https://github.com/anjuke/12factor/issues">翻译问题反馈</a></em></p>

<h4>简介</h4>

<p>如今，软件通常会作为一种服务来交付，它们被称为“互联网应用程序”（web apps），或“软件即服务”（SaaS）。这篇“<strong><em>互联网应用的十二要素</em></strong>”为构建如下的互联网应用程序提供了指导方法：</p>

<ul>
<li>使用<strong>标准化</strong>流程自动配置，从而使新的开发者花费最少的学习成本加入这个项目；</li>
<li>和操作系统之间尽可能的<strong>划清界限</strong>，在各个系统中提供<strong>最大的可移植性</strong>；</li>
<li>适合<strong>部署</strong>在现代的<strong>云计算平台</strong>，从而在服务器和系统管理方面节省资源；</li>
<li>将开发环境和生产环境的<strong>差异降至最低</strong>，并使用<strong>持续交付</strong>实施敏捷开发；</li>
<li>可以在工具、架构和开发流程不发生明显变化的前提下实现<strong>扩展</strong>；</li>
</ul>


<p>这套理论适用于任意语言和后端服务（数据库、消息队列、缓存等）开发的应用程序。</p>

<h4>背景</h4>

<p>本文的贡献者参与过数以百计的应用程序的开发和部署，并通过<a href="http://www.heroku.com/">Heroku</a>平台间接见证了数十万应用程序的开发，运作以及扩展的过程。</p>

<p>本文综合了我们关于SaaS应用几乎所有的经验和智慧，是开发此类应用的理想实践标准，并特别关注于应用程序如何保持良性成长，开发者之间如何进行有效的代码协作，以及如何<a href="http://blog.heroku.com/archives/2011/6/28/the_new_heroku_4_erosion_resistance_explicit_contracts/">避免软件污染</a>。</p>

<p>我们的初衷是分享在现代软件开发过程中发现的一些系统性问题，并加深对这些问题的认识。我们提供了讨论这些问题时所需的共享词汇，同时使用相关术语给出一套针对这些问题的广义解决方案。本文格式的灵感来自于Martin Fowler的书籍：<a href="http://books.google.com/books/about/Patterns_of_enterprise_application_archi.html?id=FyWZt5DdvFkC"><em>Patterns of Enterprise Application Architecture</em></a>，<a href="http://books.google.com/books/about/Refactoring.html?id=1MsETFPD3I0C"><em>Refactoring</em></a>。</p>

<h4>读者应该是哪些人？</h4>

<p>任何SaaS应用的开发人员；部署和管理此类应用的运维工程师。</p>

<!-- more -->


<h2>I. 基准代码</h2>

<p><strong><em>一份基准代码（<em>Codebase</em>)，多份部署(<em>deploy</em>)</em></strong></p>

<p>12-Factor App(译者注：应该是说一个使用本文概念来设计的应用，下同)通常会使用版本控制系统加以管理，如<a href="http://git-scm.com/">Git</a>, <a href="http://mercurial.selenic.com/">Mercurial</a>, <a href="http://subversion.apache.org/">Subversion</a>。一份用来跟踪代码所有修订版本的数据库被称作 <em>代码库</em> （code repository, code repo, repo）。</p>

<p>在类似SVN这样的集中式版本控制系统中， <em>基准代码</em> 就是指控制系统中的这一份代码库；而在Git那样的分布式版本控制系统中， <em>基准代码</em> 则是指最上游的那份代码库。</p>

<p><img src="https://github.com/anjuke/12factor/raw/zh_CN/public/images/codebase-deploys.png" alt="一份代码库对应多份部署" /></p>

<p>基准代码和应用之间总是保持一一对应的关系：</p>

<ul>
<li>一旦有多个基准代码，就不能称为一个应用，而是一个分布式系统。分布式系统中的每一个组件都是一个应用，每一个应用可以分别使用12-Factor进行开发。</li>
<li>多个应用共享一份基准代码是有悖于12-Factor原则的。解决方案是将共享的代码拆分为独立的类库，然后使用<a href="#dependencies">依赖管理</a>策略去加载它们。</li>
</ul>


<p>尽管每个应用只对应一份基准代码，但可以同时存在多份部署。每份 <em>部署</em> 相当于运行了一个应用的实例。通常会有一个生产环境，一个或多个预发布环境。此外，每个开发人员都会在自己本地环境运行一个应用实例，这些都相当于一份部署。</p>

<p>所有部署的基准代码相同，但每份部署可以使用其不同的版本。比如，开发人员可能有一些提交还没有同步至预发布环境；预发布环境也有一些提交没有同步至生产环境。但它们都共享一份基准代码，我们就认为它们只是相同应用的不同部署而已。</p>

<h2>II. 依赖</h2>

<p><strong><em>显式声明依赖关系(<em>dependency</em>)</em></strong></p>

<p>大多数编程语言都会提供一个打包系统，用来为各个类库提供打包服务，就像Perl的<a href="http://www.cpan.org/">CPAN</a>或是Ruby的<a href="http://rubygems.org/">Rubygems</a>。通过打包系统安装的类库可以是系统级的（称之为&#8221;site packages&#8221;），或仅供某个应用程序使用，部署在相应的目录中（称之为&#8221;vendoring&#8221;或&#8221;bunding&#8221;）。</p>

<p><strong>12-Factor规则下的应用程序不会隐式依赖系统级的类库。</strong> 它一定通过 <em>依赖清单</em> ，确切地声明所有依赖项。此外，在运行过程中通过 <em>依赖隔离</em> 工具来确保程序不会调用系统中存在但清单中未声明的依赖项。这一做法会统一应用到生产和开发环境。</p>

<p>例如，Ruby的<a href="http://gembundler.com/">Gem Bundler</a>使用<code>Gemfile</code>作为依赖项声明清单，使用<code>bundle exec</code>来进行依赖隔离。Python中则可分别使用两种工具 &mdash; <a href="http://www.pip-installer.org/en/latest/">Pip</a>用作依赖声明，<a href="http://www.virtualenv.org/en/latest/">Virtualenv</a>用作依赖隔离。甚至C语言也有类似工具，<a href="http://www.gnu.org/s/autoconf/">Autoconf</a>用作依赖声明，静态链接库用作依赖隔离。无论用什么工具，依赖声明和依赖隔离必须一起使用，否则无法满足12-Factor规范。</p>

<p>显式声明依赖的优点之一是为新进开发者简化了环境配置流程。新进开发者可以检出应用程序的基准代码，安装编程语言环境和它对应的依赖管理工具，只需通过一个 <em>构建命令</em> 来安装所有的依赖项，即可开始工作。例如，Ruby/Bundler下使用<code>bundle install</code>，而Clojure/<a href="https://github.com/technomancy/leiningen#readme">Leiningen</a>则是<code>lein deps</code>。</p>

<p>12-Factor应用同样不会隐式依赖某些系统工具，如ImageMagick或是<code>curl</code>。即使这些工具存在于几乎所有系统，但终究无法保证所有未来的系统都能支持应用顺利运行，或是能够和应用兼容。如果应用必须使用到某些系统工具，那么这些工具应该被包含在应用之中。</p>

<h2>III. 配置</h2>

<p><strong><em>在环境中存储配置</em></strong></p>

<p>通常，应用的<em>配置</em>在不同<a href="#codebase">部署</a> (预发布、生产环境、开发环境等等)间会有很大差异。这其中包括：</p>

<ul>
<li>数据库，Memcached，以及其他<a href="#backing-services">后端服务</a>的配置</li>
<li>第三方服务的证书，如Amazon S3、Twitter等</li>
<li>每份部署特有的配置，如域名等</li>
</ul>


<p>有些应用在代码中使用常量保存配置，这与12-factor所要求的<strong>代码和配置严格分离</strong>显然大相径庭。配置文件在各部署间存在大幅差异，代码却完全一致。</p>

<p>判断一个应用是否正确地将配置排除在代码之外，一个简单的方法是看该应用的基准代码是否可以立刻开源，而不用担心会暴露任何敏感的信息。</p>

<p>需要指出的是，这里定义的&#8221;配置&#8221;并<strong>不</strong>包括应用的内部配置，比如Rails的<code>config/routes.rb</code>，或是使用<a href="http://www.springsource.org/">Spring</a>时<a href="http://static.springsource.org/spring/docs/2.5.x/reference/beans.html">代码模块间的依赖注入关系</a>。这类配置在不同部署间不存在差异，所以应该写入代码。</p>

<p>另外一个解决方法是使用配置文件，但不把它们纳入版本控制系统，就像Rails的<code>config/database.yml</code> 。这相对于在代码中使用常量已经是长足进步，但仍然有缺点：总是会不小心将配置文件签入了代码库；配置文件的可能会分散在不同的目录，并有着不同的格式，这让找出一个地方来统一管理所有配置变的不太现实。更糟的是，这些格式通常是语言或框架特定的。</p>

<p><strong>12-Factor推荐将应用的配置存储于<em>环境变量</em>中</strong> (<em>env vars</em>, <em>env</em>) 。环境变量可以非常方便地在不同的部署间做修改，却不动一行代码；与配置文件不同，不小心把它们签入代码库的概率微乎其微；与一些传统的解决配置问题的机制（比如Java的属性配置文件）相比，环境变量与语言和系统无关。</p>

<p>配置管理的另一个方面是分组。有时应用会将配置按照特定部署进行分组（或叫做“环境”），例如Rails中的<code>development</code>、<code>test</code>和<code>production</code>环境。这种方法无法轻易扩展：更多部署意味着更多新的环境，例如<code>staging</code>或<code>qa</code>。随着项目的不断深入，开发人员可能还会添加他们自己的环境，比如<code>joes-staging</code>，这将导致各种配置组合的激增，从而给管理部署增加了很多不确定因素。</p>

<p>12-Factor应用中，环境变量的粒度要足够小，且相对独立。它们永远也不会组合成一个所谓的“环境”，而是独立存在于每个部署之中。当应用程序不断扩展，需要更多种类的部署时，这种配置管理方式能够做到平滑过渡。</p>

<h2>IV. 后端服务</h2>

<p><strong><em>把后端服务(<em>backing services</em>)当作附加资源</em></strong></p>

<p><em>后端服务</em> 是指程序运行所需要的通过网络调用的各种服务，如数据库(<a href="http://dev.mysql.com/">MySQL</a>，<a href="http://couchdb.apache.org/">CouchDB</a>)，消息/队列系统(<a href="http://www.rabbitmq.com/">RabbitMQ</a>，<a href="http://kr.github.com/beanstalkd/">Beanstalkd</a>)，SMTP邮件发送服务(<a href="http://www.postfix.org/">Postfix</a>)，以及缓存系统(<a href="http://memcached.org/">Memcached</a>)。</p>

<p>类似数据库的后端服务，通常由部署应用程序的系统管理员一起管理。除了本地服务之外，应用程序有可能使用了第三方发布和管理的服务。示例包括SMTP(例如 <a href="http://postmarkapp.com/">Postmark</a>)，数据收集服务（例如 <a href="http://newrelic.com/">New Relic</a> 或 <a href="http://www.loggly.com/">Loggly</a>），数据存储服务（如<a href="http://http://aws.amazon.com/s3/">Amazon S3</a>），以及使用API访问的服务(例如 <a href="http://dev.twitter.com/">Twitter</a>, <a href="http://code.google.com/apis/maps/index.html">Google Maps</a>, <a href="http://www.last.fm/api">Last.fm</a>)。</p>

<p><strong>12-Factor应用不会区别对待本地或第三方服务。</strong> 对应用程序而言，两种都是附加资源，通过一个url或是其他存储在<a href="#config">配置</a>中的服务定位/服务证书来获取数据。12-Factor应用的任意<a href="#codebase">部署</a> ，都应该可以在不进行任何代码改动的情况下，将本地MySQL数据库换成第三方服务(例如 <a href="http://aws.amazon.com/rds/">Amazon RDS</a>)。类似的，本地SMTP服务应该也可以和第三方SMTP服务(例如Postmark)互换。上述2个例子中，仅需修改配置中的资源地址。</p>

<p>每个不同的后端服务是一份<em>资源</em>。例如，一个MySQL数据库是一个资源，两个MySQL数据库(用来数据分区)就被当作是2个不同的资源。12-factor应用将这些数据库都视作<em>附加资源</em>，并且与这些附加资源保持松耦合。</p>

<p><img src="https://github.com/anjuke/12factor/raw/zh_CN/public/images/attached-resources.png" alt="一种部署附加4个后端服务" /></p>

<p>部署可以按需加载或卸载资源。例如，如果应用的数据库服务由于硬件问题出现异常，管理员可以从最近的备份中恢复一个数据库，卸载当前的数据库，然后加载新的数据库 &mdash; 整个过程都不需要修改代码。</p>

<h2>V. 构建，发布，运行</h2>

<p><strong><em>严格分离构建和运行</em></strong></p>

<p><a href="#codebase">基准代码</a> 转化为一份部署(非开发环境)需要以下三个阶段：</p>

<ul>
<li><em>构建阶段</em>是指将代码仓库转化为可执行包的过程。构建时会使用指定版本的代码，获取和打包<a href="#dependencies">依赖项</a>，编译成二进制文件和资源文件。</li>
<li><em>发布阶段</em>会将构建的结果和当前部署所需<a href="#config">配置</a>相结合，并能够立刻在运行环境中投入使用。</li>
<li><em>运行阶段</em>（或者说“运行时”）是指针对选定的发布版本，在执行环境中启动一系列应用程序<a href="#processes">进程</a>。</li>
</ul>


<p><img src="https://github.com/anjuke/12factor/raw/zh_CN/public/images/release.png" alt="代码被构建，然后和配置结合成为发布版本" /></p>

<p><strong>12-facfor应用严格区分构建、发布、运行这三个步骤。</strong> 举例来说，直接修改处于运行状态的代码是非常不可取的做法，因为这些修改很难再同步回构建步骤。</p>

<p>部署工具通常都提供了发布管理工具，最引人注目的功能是退回至较旧的发布版本。比如，<a href="https://github.com/capistrano/capistrano/wiki">Capistrano</a>将所有发布版本都存储在一个叫<code>releases</code>的子目录中，当前的在线版本只需映射至对应的目录即可。该工具的<code>rollback</code>命令可以很容易地实现回退版本的功能。</p>

<p>每一个发布版本必须对应一个唯一的发布ID，例如可以使用发布时的时间戳(<code>2011-04-06-20:32:17</code>)，亦或是一个增长的数字(<code>v100</code>) 。发布的版本就像一本只能追加的账本，一旦发布就不可修改，任何的变动都应该产生一个新的发布版本。</p>

<p>新的代码在部署之前，需要开发人员触发构建操作。但是，运行阶段不一定需要人为触发，而是可以自动进行。如服务器重启，或是进程管理器重启了一个崩溃的进程。因此，运行阶段应该保持尽可能少的模块，这样假设半夜发生系统故障而开发人员又捉襟见肘也不会引起太大问题。构建阶段是可以相对复杂一些的，因为错误信息能够立刻展示在开发人员面前，从而得到妥善处理。</p>

<h2>VI. 进程</h2>

<p><strong><em>以一个或多个无状态进程运行应用</em></strong></p>

<p>运行环境中，应用程序通常是以一个和多个<em>进程</em>运行的。</p>

<p>最简单的场景中，代码是一个独立的脚本，运行环境是开发人员自己的笔记本电脑，进程由一条命令行(例如<code>python my_script.py</code>)。另外一个极端情况是，复杂的应用可能会使用很多<a href="#concurrency">进程类型</a>，也就是零个或多个进程实例。</p>

<p><strong>12-factor应用的进程必须无状态且<a href="http://en.wikipedia.org/wiki/Shared_nothing_architecture">无共享</a> 。</strong> 任何需要持久化的数据都要存储在<a href="#backing-services">后端服务</a>内，比如数据库。</p>

<p>内存区域或磁盘空间可以作为进程在做某种事务型操作时的缓存，例如下载一个很大的文件，对其操作并将结果写入数据库的过程。12-Factor应用根本不用考虑这些缓存的内容是不是可以保留给之后的请求来使用，这是因为应用启动了多种类型的进程，将来的请求多半会由其他进程来服务。即使在只有一个进程的情形下，先前保存的数据（内存或文件系统中）也会因为重启（如代码部署、配置更改、或运行环境将进程调度至另一个物理区域执行）而丢失。</p>

<p>源文件打包工具(<a href="http://documentcloud.github.com/jammit/">Jammit</a>, <a href="http://code.google.com/p/django-assetpackager/">django-assetpackager</a>) 使用文件系统来缓存编译过的源文件。12-factor应用更倾向于在<a href="#build-release-run">构建步骤</a> 做此动作——正如<a href="http://ryanbigg.com/guides/asset_pipeline.html">Rails资源管道</a>，而不是在运行阶段。</p>

<p>一些互联网系统依赖于<a href="http://en.wikipedia.org/wiki/Load_balancing_%28computing%29#Persistence">“粘性session”</a>，这是指将用户session中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程。粘性Session是twelve-factor极力反对的。Session中的数据应该保存在诸如<a href="http://memcached.org/">Memcached</a>或<a href="http://redis.io/">Redis</a>这样的带有过期时间的缓存中。</p>

<h2>VII. 端口绑定</h2>

<p><strong><em>通过端口绑定(<em>Port binding</em>)来提供服务</em></strong></p>

<p>互联网应用有时会运行于服务器的容器之中。例如PHP经常作为<a href="http://httpd.apache.org/">Apache HTTPD</a>的一个模块来运行，正如Java运行于<a href="http://tomcat.apache.org/">Tomcat</a> 。</p>

<p><strong>12-factor应用完全自我加载</strong>而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用<strong>通过端口绑定来提供服务</strong>，并监听发送至该端口的请求。</p>

<p>本地环境中，开发人员通过类似<code>http://localhost:5000/</code>的地址来访问服务。在线上环境中，请求统一发送至公共域名而后路由至绑定了端口的网络进程。</p>

<p>通常的实现思路是，将网络服务器类库通过<a href="#dependencies">依赖声明</a> 载入应用。例如，Python的<a href="http://www.tornadoweb.org/">Tornado</a>、Ruby的<a href="http://code.macournoyer.com/thin/">Thin</a>、Java以及其他基于JVM语言的<a href="http://jetty.codehaus.org/jetty/">Jetty</a>。完全由<em>用户端</em>，确切的说应该是应用的代码，发起请求。和运行环境约定好绑定的端口即可处理这些请求。</p>

<p>HTTP并不是唯一一个可以由端口绑定提供的服务。其实几乎所有服务器软件都可以通过进程绑定端口来等待请求。例如，使用<a href="http://xmpp.org/">XMPP</a>的<a href="http://www.ejabberd.im/">ejabberd</a>，以及使用<a href="http://redis.io/topics/protocol">Redis协议</a>的<a href="http://redis.io/">Redis</a>。</p>

<p>还要指出的是，端口绑定这种方式也意味着一个应用可以成为另外一个应用的<a href="#backing-services">后端服务</a>，调用方将服务方提供的相应URL当作资源存入<a href="#config">配置</a> 以备将来调用。</p>

<h2>VIII. 并发</h2>

<p><strong><em>通过进程模型进行扩展</em></strong></p>

<p>任何计算机程序，一旦启动，就会生成一个或多个进程。互联网应用采用多种进程运行方式。例如，PHP进程作为Apache的子进程存在，随请求按需启动。Java进程则采取了相反的方式，在程序启动之初JVM就提供了一个超级进程储备了大量的系统资源(CPU和内存)，并通过多线程实现内部的并发管理。上述2个例子中，进程是开发人员可以操作的最小单位。</p>

<p><img src="https://github.com/anjuke/12factor/raw/zh_CN/public/images/process-types.png" alt="扩展表现为运行中的进程，工作多样性表现为进程类型。" /></p>

<p><strong>在12-factor应用中，进程是一等公民。</strong> 12-factor应用的进程主要借鉴于<a href="http://adam.heroku.com/past/2011/5/9/applying_the_unix_process_model_to_web_apps/">unix守护进程模型</a>。开发人员可以运用这个模型去设计应用架构，将不同的工作分配给不同的<em>进程类型</em>。例如，HTTP请求可以交给web进程来处理，而常驻的后台工作则交由worker进程负责。</p>

<p>这并不表示应用不能通过单个进程来处理并发，如使用VM运行时的线程机制，或是由<a href="http://rubyeventmachine.com/">EventMachine</a>、<a href="http://twistedmatrix.com/trac/">Twisted</a>、<a href="http://nodejs.org/">Node.js</a>等工具提供的异步/事件驱动模型。但是，单个VM的垂直扩展能力是有限的，所以应用必须能够扩展到多台物理机器上运行。。</p>

<p>在需要对系统进行扩展时，进程模型的作用会大放异彩。<a href="#processes">12-factor应用的进程所具备的无共享，水平分区的特性</a>意味着增加并发处理能力会是一项简单而稳妥的操作。这些进程的类型以及每个类型中进程的数量就被称作<em>进程构成</em> 。</p>

<p>12-factor应用<a href="http://dustin.github.com/2010/02/28/running-processes.html">不需要作为守护进程启动</a>或是写入PID文件。相反的，应该借助操作系统的进程管理器(例如<a href="http://upstart.ubuntu.com/">Upstart</a>，分布式的进程管理云平台，或在开发环境中使用类似<a href="http://blog.daviddollar.org/2011/05/06/introducing-foreman.html">Foreman</a>的工具)，来管理<a href="#logs">输出流</a>，应对进程崩溃，以及处理用户触发的重启和关闭操作。</p>

<h2>IX. 易处理</h2>

<p><strong><em>快速启动和优雅终止可最大化健壮性</em></strong></p>

<p><strong>12-factor应用的[进程]#/processes)是<em>可支配</em>的，意思是说它们可以瞬间开启或停止。</strong> 这有利于快速、弹性的伸缩应用，迅速部署变化的<a href="#codebase">代码</a>或<a href="#config">配置</a> ，稳健的部署应用。</p>

<p>进程应当追求<strong>最小启动时间</strong>。理想状态下，进程从敲下命令到真正启动并等待请求的时间应该只需很短的时间。更少的启动时间提供了更敏捷的<a href="#build-release-run">发布</a> 以及扩展过程，此外还增加了健壮性，因为进程管理器可以在授权情形下容易的将进程搬到新的物理机器上。</p>

<p>进程<strong>一旦接收<a href="http://en.wikipedia.org/wiki/SIGTERM">终止信号(<code>SIGTERM</code>)</a>就会优雅的终止</strong>。就网络进程而言，优雅终止是指停止监听服务的端口，即拒绝所有新的请求，并继续执行当前已接收的请求，然后退出。此类型的进程所隐含的要求是HTTP请求大多都很短(不会超过几秒钟)，而在长时间轮询中，客户端在丢失连接后应该马上尝试重连。</p>

<p>对于worker进程来说，优雅终止是指将当前任务退回队列。例如，<a href="http://www.rabbitmq.com/">RabbitMQ</a>中，worker可以发送一个<a href="http://www.rabbitmq.com/amqp-0-9-1-quickref.html#basic.nack"><code>NACK</code></a>信号。<a href="http://kr.github.com/beanstalkd/">Beanstalkd</a>中，任务终止并退回队列会在worker断开时自动触发。有锁机制的系统诸如<a href="https://github.com/collectiveidea/delayed_job#readme">Delayed Job</a>则需要确定释放了系统资源。此类型的进程所隐含的要求是，任务都应该 <a href="http://en.wikipedia.org/wiki/Reentrant_%28subroutine%29">可重复执行</a>，这主要由将结果包装进事务或是使重复操作<a href="http://en.wikipedia.org/wiki/Idempotence">幂等</a>来实现。</p>

<p>进程还应当<strong>在面对突然死亡时保持健壮</strong>，例如底层硬件故障。虽然这种情况比起优雅终止来说少之又少，但终究有可能发生。一种推荐的方式是使用一个健壮的后端队列，例如<a href="http://kr.github.com/beanstalkd/">Beanstalkd</a>，它可以在客户端断开或超时后自动退回任务。无论如何，12-factor应用都应该可以设计能够应对意外的、不优雅的终结。<a href="http://lwn.net/Articles/191059/">Crash-only design</a>将这种概念转化为<a href="http://couchdb.apache.org/docs/overview.html">合乎逻辑的理论</a>。</p>

<h2>X. 开发环境与线上环境等价</h2>

<p><strong><em>尽可能的保持开发，预发布，线上环境相同</em></strong></p>

<p>从以往经验来看，开发环境（即开发人员的本地<a href="#codebase">部署</a>）和线上环境（外部用户访问的真实部署）之间存在着很多差异。这些差异表现在以下三个方面：</p>

<ul>
<li><strong>时间差异：</strong> 开发人员正在编写的代码可能需要几天，几周，甚至几个月才会上线。</li>
<li><strong>人员差异：</strong> 开发人员编写代码，运维人员部署代码。</li>
<li><strong>工具差异：</strong> 开发人员或许使用Nginx，SQLite，OS X，而线上环境使用Apache，MySQL以及Linux。</li>
</ul>


<p><strong>12-factor应用想要做到<a href="http://www.avc.com/a_vc/2011/02/continuous-deployment.html">持续部署</a>就必须缩小本地与线上差异。</strong> 再回头看上面所描述的三个差异:</p>

<ul>
<li>缩小时间差异：开发人员可以几小时，甚至几分钟就部署代码。</li>
<li>缩小人员差异：开发人员不只要编写代码，更应该密切参与部署过程以及代码在线上的表现。</li>
<li>缩小工具差异：尽量保证开发环境以及线上环境的一致性。</li>
</ul>


<p>将上述总结变为一个表格如下：</p>

<table>
  <tr>
    <th></th>
    <th>传统应用</th>
    <th>12-factor应用</th>
  </tr>
  <tr>
    <th>每次部署间隔</th>
    <td>数周</td>
    <td>几小时</td>
  </tr>
  <tr>
    <th>开发人员 vs 运维人员</th>
    <td>不同的人</td>
    <td>相同的人</td>
  </tr>
  <tr>
    <th>开发环境 vs 线上环境</th>
    <td>不同</td>
    <td>尽量接近</td>
  </tr>
</table>


<p><a href="#backing-services">后端服务</a> 是保持开发与线上等价的重要部分，例如数据库，队列系统，以及缓存。许多语言都提供了简化获取后端服务的类库，例如不同类型服务的<em>适配器</em>。下列表格提供了一些例子。</p>

<table>
  <tr>
    <th>类型</th>
    <th>语言</th>
    <th>类库</th>
    <th>适配器</th>
  </tr>
  <tr>
    <td>数据库</td>
    <td>Ruby/Rails</td>
    <td>ActiveRecord</td>
    <td>MySQL, PostgreSQL, SQLite</td>
  </tr>
  <tr>
    <td>队列</td>
    <td>Python/Django</td>
    <td>Celery</td>
    <td>RabbitMQ, Beanstalkd, Redis</td>
  </tr>
  <tr>
    <td>缓存</td>
    <td>Ruby/Rails</td>
    <td>ActiveSupport::Cache</td>
    <td>Memory, filesystem, Memcached</td>
  </tr>
</table>


<p>开发人员有时会觉得在本地环境中使用轻量的后端服务具有很强的吸引力，而那些更重量级的健壮的后端服务应该使用在生产环境。例如，本地使用SQLite线上使用PostgreSQL；又如本地缓存在进程内存中而线上存入Memcached。</p>

<p><strong>12-factor应用的开发人员应该反对在不同环境间使用不同的后端服务</strong>，即使适配器已经可以几乎消除使用上的差异。这是因为，不同的后端服务意味着会突然出现的不兼容，从而导致测试、预发布都正常的代码在线上出现问题。这些错误会给持续部署带来阻力。从应用程序的生命周期来看，消除这种阻力需要花费很大的代价。</p>

<p>与此同时，轻量的本地服务也不像以前那样引人注目。借助于<a href="http://mxcl.github.com/homebrew/">Homebrew</a>，<a href="https://help.ubuntu.com/community/AptGet/Howto">apt-get</a>等现代的打包系统，诸如Memcached、PostgreSQL、RabbitMQ等后端服务的安装与运行也并不复杂。此外，使用类似<a href="http://www.opscode.com/chef/">Chef</a>和<a href="http://docs.puppetlabs.com/">Puppet</a>的声明式配置工具，结合像<a href="http://vagrantup.com/">Vagrant</a>这样轻量的虚拟环境就可以使得开发人员的本地环境与线上环境无限接近。与同步环境和持续部署所带来的益处相比，安装这些系统显然是值得的。</p>

<p>不同后端服务的适配器仍然是有用的，因为它们可以使移植后端服务变得简单。但应用的所有部署，这其中包括开发、预发布以及线上环境，都应该使用同一个后端服务的相同版本。</p>

<h2>XI. 日志</h2>

<p><strong><em>把日志当作事件流</em></strong></p>

<p><em>日志</em>使得应用程序运行的动作变得透明。在基于服务器的环境中，日志通常被写在硬盘的一个文件里，但这只是一种输出格式。</p>

<p>日志应该是<a href="http://adam.heroku.com/past/2011/4/1/logs_are_streams_not_files/">事件流</a>的汇总，将所有运行中进程和后端服务的输出流按照时间顺序收集起来。日志的原始形式通常是文本文件，一行一个事件（程序异常产生的跟踪信息会跨越多行）。日志没有确定开始和结束，但随着应用在运行会持续的增加。</p>

<p><strong>12-factor应用本身从不考虑存储自己的输出流。</strong> 不应该试图去写或者管理日志文件。相反，每一个运行的进程都会直接的标准输出(<code>stdout</code>)事件流。开发环境中，开发人员可以通过这些数据流，实时在终端看到应用的活动。</p>

<p>在预发布或线上部署中，每个进程的输出流由运行环境截获，并将其他输出流整理在一起，然后一并发送给一个或多个最终的处理程序，用于查看或是长期存档。这些存档路径对于应用来说不可见也不可配置，而是完全交给程序的运行环境管理。类似<a href="https://github.com/heroku/logplex">Logplex</a>和<a href="https://github.com/fluent/fluentd">Fluent</a>的开源工具可以达到这个目的。</p>

<p>这些事件流可以输出至文件，或者在终端实时观察。最重要的，输出流可以发送到<a href="http://www.splunk.com/">Splunk</a>这样的日志索引及分析系统，或<a href="http://hive.apache.org/">Hadoop/Hive</a>这样的通用数据存储系统。这些系统为查看应用的历史活动提供了强大而灵活的功能，包括：</p>

<ul>
<li>找出过去一段时间特殊的事件。</li>
<li>图形化一个大规模的趋势，比如每分钟的请求量。</li>
<li>根据用户定义的条件实时触发警报，比如每分钟的报错超过某个警戒线。</li>
</ul>


<h2>XII. 管理进程</h2>

<p><strong><em>后台管理任务当作一次性进程运行</em></strong></p>

<p><a href="#concurrency">进程构成</a> 是指用来处理应用的常规业务(比如处理web请求)的一组进程。与此不同，开发人员经常希望执行一些管理或维护应用的一次性任务，例如：</p>

<ul>
<li>运行数据移植（Django中的<code>manage.py syncdb</code>, Rails中的<code>rake db:migrate</code>）。</li>
<li>运行一个控制台（也被称为<a href="http://en.wikipedia.org/wiki/Read-eval-print_loop">REPL</a> shell），来执行一些代码或是针对线上数据库做一些检查。大多数语言都通过解释器提供了一个REPL工具(<code>python</code>或<code>erl</code>) ，或是其他命令（Ruby使用 <code>irb</code>, Rails使用 <code>rails console</code> ）。</li>
<li>运行一些提交到代码仓库的一次性脚本。</li>
</ul>


<p>一次性管理进程应该和正常的<a href="#processes">常驻进程</a>使用同样的环境。这些管理进程和任何其他的进程一样使用相同的<a href="#codebase">代码</a>和<a href="#config">配置</a>，基于某个<a href="#build-release-run">发布版本</a>运行。后台管理代码应该随其他应用程序代码一起发布，从而避免同步问题。</p>

<p>所有进程类型应该使用同样的<a href="#dependencies">依赖隔离</a>技术。例如，如果Ruby的web进程使用了命令<code>bundle exec thin start</code>，那么数据库移植应使用<code>bundle exec rake db:migrate</code>。同样的，如果一个Python程序使用了Virtualenv，则需要在运行Tornado Web服务器和任何<code>manage.py</code>管理进程时引入‵bin/python‵ 。</p>

<p>12-factor尤其青睐那些提供了REPL shell的语言，因为那会让运行一次性脚本变得简单。在本地部署中，开发人员直接在命令行使用shell命令调用一次性管理进程。在线上部署中，开发人员依旧可以使用ssh或是运行环境提供的其他机制来运行这样的进程。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安居客导师指南]]></title>
    <link href="http://liangshan.me/blog/2014/05/22/how-to-teach-people-at-anjuke/"/>
    <updated>2014-05-22T11:23:34+08:00</updated>
    <id>http://liangshan.me/blog/2014/05/22/how-to-teach-people-at-anjuke</id>
    <content type="html"><![CDATA[<p>安居客近年来非常重视校招，尤其是研发方向。实际操作下来，感觉校招还是不错的选择，这次我主要站在公司的角度来说。</p>

<!-- more -->


<p>公司应该是看中应届毕业生便宜、够用、潜力。这里要说一个现象，大多数很优秀的应届生都选择去了大公司，类似 BAT，薪水高、品牌响这倒也无可厚非。所以这里讨论的是我接触到的学生们，并非是说公司的招到的学生不好，只是学生之间是有差距的这也是事实。</p>

<p>当然招校招生也存在几个风险，其中最大的风险无非就是学生也只是把公司当跳板。对于这个我的观点比较简单，说明公司的吸引力不够，这个不怪学生。
对此安居客的对策是为学生安排专人辅导，我们内部称为「导师」，或者是 buddy。这里导师的作用除了辅导之外，其实很大程度上是为了留住学生，所以导师的选择和导师的付出其实和最后学生的发展有着比较密切的关系。</p>

<p>我有幸参与了安居客的几届学生培养，作为导师代表给所有导师做了一次分享。这里贴上 slides:</p>

<script async class="speakerdeck-embed" data-id="1b324900a388013120061af8c79ec55f" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Virtualenv 绿色安装 Ansible]]></title>
    <link href="http://liangshan.me/blog/2014/05/20/using-ansible-with-virtualenv-without-install/"/>
    <updated>2014-05-20T14:45:59+08:00</updated>
    <id>http://liangshan.me/blog/2014/05/20/using-ansible-with-virtualenv-without-install</id>
    <content type="html"><![CDATA[<p><a href="http://www.ansible.com/home">Ansible</a> 是一个自动化配置管理工具 (Automate configure management)。用 python 编写，所以安装方式一般有以下几种：</p>

<p><strong> <code>pip</code> 安装 </strong></p>

<pre><code>$ pip install ansible
</code></pre>

<p><strong> MacOS 用户可以选择使用 <code>homebrew</code> 安装 </strong></p>

<pre><code>$ brew install ansible
</code></pre>

<p>但这两种方法都不可避免将「污染」系统的 python 环境。所以本文主要介绍如何绿色安装 Ansible。</p>

<!-- more -->


<h3>安装 Virtualenv</h3>

<p>不污染系统的关键在于虚拟化 python 的环境，所以需要准备 virtualenv。</p>

<p>这里偷懒选择使用 pip 安装，如果连 virtualenv 也不想装在系统级别也是可以的，就不在这里介绍了。</p>

<pre><code>$ pip install virtualenv
</code></pre>

<h3>下载 ansible</h3>

<pre><code>$ git clone git@github.com:ansible/ansible.git
$ cd ansible
</code></pre>

<h3>安装</h3>

<pre><code>$ virtualenv .virtualenv
$ .virtualenv/bin/python setup.py develop
</code></pre>

<h3>A little trick</h3>

<p>这个时候使用 virtualenv 激活当前目录的 python 环境，其实 <code>bin/ansible</code> 就已经可以工作了。</p>

<p>但我们还希望将 ansible 命令加在系统的 PATH 里，这就需要一些小技巧。简单来说需要自己准备一个脚本，脚本的内容如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>touch ~/bin/_ansible_wrapper
</span><span class='line'><span class="nv">$ </span>vim ~/bin/_ansible_wrapper
</span><span class='line'>
</span><span class='line'><span class="c">#!/bin/bash</span>
</span><span class='line'><span class="nb">source</span> <span class="s2">&quot;$HOME/apps/ansible/hacking/env-setup&quot;</span> -q
</span><span class='line'><span class="k">if</span> <span class="o">[</span> -f <span class="s2">&quot;$ANSIBLE_HOME/.virtualenv/bin/activate&quot;</span> <span class="o">]</span> ; <span class="k">then</span>
</span><span class='line'><span class="k">    </span><span class="nb">source</span> <span class="s2">&quot;$ANSIBLE_HOME/.virtualenv/bin/activate&quot;</span>
</span><span class='line'><span class="k">fi</span>
</span><span class='line'><span class="nv">PYENV_VERSION</span><span class="o">=</span>2.7.6 <span class="nb">exec</span> <span class="s2">&quot;$ANSIBLE_HOME/bin/${0##/*/}&quot;</span> <span class="nv">$@</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>$HOME/apps/ansible/hacking/env-setup</code> 是 ansible 为 hacker 准备的一个脚本，设置一些环境变量。其中 <code>$HOME/apps/ansible</code> 是 ansible 的根目录。</p>

<p><code>${0##/*/}</code> 比较有趣，作用是正则匹配 <code>/*/</code> 然后把匹配到的部分从第 0 个参数（即命令本身）中删除。关于 bash 参数，更详细可以看[1]。</p>

<p><code>$@</code> 则比较常见，是 bash 拿到的除命令名之外的所有参数。</p>

<p>其实这个脚本就是一个 wrapper，作用如下：</p>

<ol>
<li>设置相关环境变量</li>
<li>激活 ansible 下的 python 环境</li>
<li>将收到的所有命令都转发给 <code>$ANSIBLE_HOME/bin</code> 下的相同命令执行</li>
</ol>


<p>假设 <code>$HOME/bin</code> 在 PATH 中，设置几个软链就全部搞定了。</p>

<pre><code>$ ln -s $HOME/bin/_ansible_wrapper $HOME/bin/ansible
$ ln -s $HOME/bin/_ansible_wrapper $HOME/bin/ansible-playbook
$ ln -s $HOME/bin/_ansible_wrapper $HOME/bin/ansible-galaxy
</code></pre>

<h3>参考资料</h3>

<ol>
<li><a href="http://www.ibm.com/developerworks/opensource/library/l-bash-parameters/index.html">Linux tip: Bash parameters and parameter expansions</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Octopress 在 GitHub Pages 上快速搭建自定义域名Blog]]></title>
    <link href="http://liangshan.me/blog/2014/05/12/build-custom-domain-blog-with-octopress-and-github-pages/"/>
    <updated>2014-05-12T14:17:19+08:00</updated>
    <id>http://liangshan.me/blog/2014/05/12/build-custom-domain-blog-with-octopress-and-github-pages</id>
    <content type="html"><![CDATA[<p>一直没有搭博客，因为一直感觉自己不是一个标准的技术人，主要是不够狂热。但受身边人熏陶，偶尔还是想写点东西。
尤其是看中 <code>liangshan.me</code> 这个域名，买下之后觉得闲着也是浪费，所以有了利用 GitHub Pages 来搭一下的想法。</p>

<h2>预备</h2>

<ul>
<li>你需要具备一些 <code>Git</code> 的常识</li>
<li>你需要一张 Visa 卡或是支付宝账号</li>
<li>如果有 Ruby 经验，将会帮你更好的理解这个系统</li>
</ul>


<h2>Quick Start</h2>

<p>整体来说，整个部署过程分3大步</p>

<ol>
<li>购买域名</li>
<li>配置解析</li>
<li>部署至 GitHub Pages</li>
<li>评论插件</li>
</ol>


<!-- more -->


<h3>购买域名</h3>

<p>这里选用 <a href="http://www.godaddy.com">Godaddy</a>， 理由很简单，就是他支持支付宝。购买和支付流程很顺畅，应该不会有什么障碍。</p>

<h3>配置解析</h3>

<p>为了防止 Godaddy 自己的 DNS 解析被墙[1]，所以选用了国内的 <a href="https://www.dnspod.cn">DNSPod</a> 来解析域名，免费服务够用，还有手机二次验证。</p>

<ol>
<li>在 Godaddy 上设置 NameServer 到 DNSPod 提供的地址</li>
<li>如果是顶级域名，需要在 DNSPod 上设置一个 A 记录到 Github Pages 的 IP 地址，这个地址可能会变化，可以查看<a href="https://help.github.com/articles/my-custom-domain-isn-t-working">这里</a>获取最新的地址</li>
<li>如果是子域名，可以设置 CNAME</li>
</ol>


<p>关于 DNS 的设置，更详细的可以看 <a href="https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages#step-1-add-a-cname-file-to-your-repository">GitHub Pages 的说明文档</a></p>

<h3>部署至 GitHub Pages</h3>

<p>关于 GitHub Pages 的技术细节，看[2]可能会有收获，一句话来概括就是<strong>使用动态语言来编辑纯文本文件，生成静态 HTML 代码，然后部署在 GitHub 上。</strong></p>

<p>这种方式很巧妙，我之前也一直在用<a href="https://github.com/liangshan/markdown2deckjs">类似的做法</a>管理我的 Slides。</p>

<p>这里并没有直接使用 Jekyll，而是使用基于他的 <a href="http://octopress.org/docs/setup/">Octopress</a>。遵循页面的 <code>Next Steps</code> 应该可以很快搭好环境。</p>

<p>并且 Octopress 做好了和 GitHub Pages 对接的<a href="http://octopress.org/docs/deploying/github/">脚手架</a>。</p>

<p>这里主要记录一些踩到的坑：</p>

<ol>
<li>使用 Homebrew 安装 rbenv, 再用 rbenv 安装 ruby, 提醒最新的 MacOS 安装的 Xcode 并没有 GCC，需要手动安装 GCC</li>
<li><code>~/.rbenv/shims</code> 目录需要添加至 PATH，Homebrew 安装过程中好像并没有做这一步，并且 Octopress 关于这部分的文档可能过时了，文档中使用的 <code>~/.rbenv/bin</code></li>
</ol>


<h3>评论插件</h3>

<p>由于是纯静态页面，所以要增加评论的动态功能 需要借助一些第三方前端工具。比如 <a href="http://disqus.com">Disqus</a>，配置非常简单 更多参考[3]。</p>

<h2>参考资料</h2>

<ol>
<li><a href="http://beiyuu.com/github-pages/">使用Github Pages建独立博客</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html">搭建一个免费的，无限流量的Blog&mdash;&mdash;github Pages和Jekyll入门</a></li>
<li><a href="http://seagg.github.io/blog/2012/09/03/config-comment-on-octopress/">给octopress添加Disqus评论功能</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
